<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generatore Set Magic (Bugfix e Stabilità)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        @font-face {
            font-family: 'Beleren Smallcaps';
            src: url('https://github.com/Hakkura/Magic-Fonts/raw/main/fonts/belerensmallcaps-bold.ttf') format('truetype');
            font-weight: bold;
            font-display: swap;
        }
        @font-face {
            font-family: 'MPlantin';
            src: url('https://github.com/Hakkura/Magic-Fonts/raw/main/fonts/mplantin.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'MPlantin';
            src: url('https://github.com/Hakkura/Magic-Fonts/raw/main/fonts/mplantin-italic.ttf') format('truetype');
            font-weight: normal;
            font-style: italic;
            font-display: swap;
        }

        body {
            font-family: 'MPlantin', 'Inter', sans-serif;
            background-color: #111827;
        }
        .beleren-font {
            font-family: 'Beleren Smallcaps', sans-serif;
        }
        .card-wrapper {
            width: 100%;
            max-width: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            position: relative;
        }
        .card-wrapper canvas {
            width: 100%;
            height: auto;
            border-radius: 4.75%;
            box-shadow: 0 15px 35px rgba(0,0,0,0.5);
            transition: transform 0.3s ease;
        }
        .card-wrapper canvas:hover {
            transform: scale(1.05) rotateZ(1deg);
        }
        #initial-loading-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(17, 24, 39, 0.95);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
        }
        .card-loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(31, 41, 55, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4.75%;
        }
        /* Stili per il form di modifica inline */
        .edit-form {
            width: 100%;
            background-color: #1f2937;
            border-radius: 14px; /* Corrisponde a 4.75% di 300px */
            padding: 1rem;
            border: 2px solid #4b5563;
        }
        .edit-form input, .edit-form textarea {
            background-color: #374151;
            color: #f3f4f6;
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid #4b5563;
        }
        .edit-form label {
            font-size: 0.875rem;
            color: #9ca3af;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="initial-loading-overlay">
        <div class="text-center">
             <svg class="animate-spin h-10 w-10 text-white mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
             <p id="loading-text" class="mt-4 text-xl text-gray-300 beleren-font">Caricamento Asset e Font...</p>
        </div>
    </div>

    <div class="container mx-auto px-4 py-8">
        <header class="text-center mb-12">
            <h1 class="beleren-font text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-yellow-300 via-orange-400 to-red-500">
                Generatore di Set MTG
            </h1>
            <p class="text-gray-400 mt-2">Crea carte di Magic ad alta fedeltà, pronte per essere scaricate e stampate.</p>
        </header>

        <div class="max-w-2xl mx-auto bg-gray-800/50 backdrop-blur-sm rounded-xl shadow-2xl p-8 mb-12">
            <div class="space-y-6">
                <div>
                    <label for="set-theme" class="block text-lg font-medium text-gray-300 mb-2">Tema del Set</label>
                    <input type="text" id="set-theme" class="w-full bg-gray-700 text-white rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500" placeholder="Es. Impero Romano intergalattico...">
                </div>
                <div>
                    <label for="card-count" class="block text-lg font-medium text-gray-300 mb-2">Numero di Carte da Generare</label>
                    <input type="number" id="card-count" class="w-full bg-gray-700 text-white rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500" value="2" min="1" max="300">
                </div>
            </div>
            <div class="mt-8 text-center">
                <button id="generate-btn" disabled class="beleren-font bg-gray-500 cursor-not-allowed text-white font-bold py-3 px-10 rounded-lg shadow-lg transition-all duration-300">
                    Caricamento...
                </button>
                <button id="stop-btn" class="hidden beleren-font bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-10 rounded-lg shadow-lg transition-all duration-300">
                    Interrompi Generazione
                </button>
            </div>
        </div>

        <div id="bulk-download-container" class="hidden text-center my-6">
             <button id="bulk-download-btn" class="beleren-font bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-lg">
                Scarica Tutte le Carte (.zip)
            </button>
        </div>

        <div id="loading-indicator" class="hidden text-center my-10">
            <svg class="animate-spin h-8 w-8 text-white mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <p id="generation-status" class="mt-4 text-gray-400">L'AI sta forgiando le carte...</p>
        </div>
        
        <div id="error-message" class="hidden text-center my-10 bg-red-500/20 text-red-300 p-4 rounded-lg"></div>

        <div id="card-display-area" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-8 justify-items-center">
        </div>
    </div>

<script>
    // Elements
    const generateBtn = document.getElementById('generate-btn');
    const stopBtn = document.getElementById('stop-btn');
    const bulkDownloadContainer = document.getElementById('bulk-download-container');
    const bulkDownloadBtn = document.getElementById('bulk-download-btn');
    const loadingIndicator = document.getElementById('loading-indicator');
    const generationStatus = document.getElementById('generation-status');
    const cardDisplayArea = document.getElementById('card-display-area');
    const errorMessage = document.getElementById('error-message');
    const initialLoadingOverlay = document.getElementById('initial-loading-overlay');
    
    // State
    let isGenerationStopped = false;
    let generatedCards = []; // ** FIX: Store card data in memory to preserve image objects

    // Constants
    const CARD_WIDTH = 375;
    const CARD_HEIGHT = 523;
    const assets = { frames: {}, ptBox: {}, symbols: {} };
    const MTG_CARDSMITH_BASE = 'https://mtgcardsmith.com';
    const FRAME_ASSETS = {
        'Standard Colors': { 'White': '/moderator/thumb/custom_666b5f5b0a7b2.jpg?v=1', 'Blue': '/moderator/thumb/custom_666b66c13041d.jpg?v=1', 'Black': '/moderator/thumb/custom_666b62e1659a8.jpg?v=1', 'Red': '/moderator/thumb/custom_666b637f49d3c.jpg?v=1', 'Green': '/moderator/thumb/custom_666b647f32017.jpg?v=1', 'Artifact': '/moderator/thumb/custom_666b64b05d996.jpg?v=1', 'Colorless': '/moderator/thumb/custom_666b64d958319.jpg?v=1', 'Land': '/moderator/thumb/custom_666b64d958319.jpg?v=1', 'Gold': '/moderator/thumb/custom_666ba621b8c9d.png?v=1' },
        'Borderless': { 'White': '/moderator/thumb/custom_66637c40bf2a2.png?v=1', 'White Legend': '/moderator/thumb/custom_666389e5e46a1.png?v=1', 'Blue': '/moderator/thumb/custom_6663822aa3c55.png?v=1', 'Blue Legend': '/moderator/thumb/custom_666382be85178.png?v=1', 'Black': '/moderator/thumb/custom_6663830c90efd.png?v=1', 'Black Legend': '/moderator/thumb/custom_666383273f96e.png?v=1', 'Red': '/moderator/thumb/custom_6663833f965ba.png?v=1', 'Red Legend': '/moderator/thumb/custom_66638376b7b51.png?v=1', 'Green': '/moderator/thumb/custom_666388ec7e198.png?v=1', 'Green Legend': '/moderator/thumb/custom_666389293baab.png?v=1', 'Gold': '/moderator/thumb/custom_66638b4a98a6e.png?v=1', 'Gold Legend': '/moderator/thumb/custom_66638b876689f.png?v=1', 'Artifact': '/moderator/thumb/custom_66638ba07c65e.png?v=1', 'Artifact Legend': '/moderator/thumb/custom_66638bcd6c326.png?v=1', 'Land': '/moderator/thumb/custom_66638ca862a35.png?v=1', 'Land Legend': '/moderator/thumb/custom_66638ce7c7962.png?v=1', 'Colorless': '/moderator/thumb/custom_66638d05e06de.png?v=1', 'Colorless Legend': '/moderator/thumb/custom_66638d29593a9.png?v=1' }
    };
    const PT_BOX_ASSETS = {
        'Standard': { 'Black': '/moderator/ptImgs/custom_66638540b2307.png', 'White': '/moderator/ptImgs/custom_666383e4ba24e.png', 'Blue': '/moderator/ptImgs/custom_66638454b50c0.png', 'Red': '/moderator/ptImgs/custom_6663850c4c508.png', 'Green': '/moderator/ptImgs/custom_6663851f571d5.png', 'Artifact': '/moderator/ptImgs/custom_66638535808c3.png', 'Colorless': '/moderator/ptImgs/custom_66638540b2307.png', 'Gold': '/moderator/ptImgs/custom_66576b60da360.png' },
        'Borderless': { 'Black': '/moderator/ptImgs/custom_6663824ab6918.png', 'White': '/moderator/ptImgs/custom_6663811764b39.png', 'Blue': '/moderator/ptImgs/custom_66638241c552b.png', 'Red': '/moderator/ptImgs/custom_6663824f56d90.png', 'Green': '/moderator/ptImgs/custom_6663825ebab9f.png', 'Artifact': '/moderator/ptImgs/custom_66638267b0ce4.png', 'Colorless': '/moderator/ptImgs/custom_6663827878b84.png', 'Gold': '/moderator/ptImgs/custom_666382623fb86.png' }
    };
    
    // ** FIX: API Key in global scope **
    const apiKey = ""; // Gestita dall'ambiente

    // --- Asset & Core Functions ---

    function loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => resolve(img);
            img.onerror = () => reject(`Impossibile caricare l'asset da ${src}`);
            img.src = src;
        });
    }

    async function preloadAssets() {
        const assetPromises = [];
        for (const style in FRAME_ASSETS) {
            if (!assets.frames[style]) assets.frames[style] = {};
            for (const color in FRAME_ASSETS[style]) {
                const url = MTG_CARDSMITH_BASE + FRAME_ASSETS[style][color];
                assetPromises.push(loadImage(url).then(img => { assets.frames[style][color] = img; }));
            }
        }
        for (const style in PT_BOX_ASSETS) {
             if (!assets.ptBox[style]) assets.ptBox[style] = {};
            for (const color in PT_BOX_ASSETS[style]) {
                const url = MTG_CARDSMITH_BASE + PT_BOX_ASSETS[style][color];
                assetPromises.push(loadImage(url).then(img => { assets.ptBox[style][color] = img; }));
            }
        }

        try {
            await Promise.all([ ...assetPromises, document.fonts.ready, preloadScryfallSymbols() ]);
            initialLoadingOverlay.style.display = 'none';
            generateBtn.disabled = false;
            generateBtn.textContent = 'Genera Carte';
            generateBtn.className = 'beleren-font bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white font-bold py-3 px-10 rounded-lg shadow-lg transform hover:scale-105 transition-transform duration-300';
        } catch (error) {
            console.error(error);
            initialLoadingOverlay.innerHTML = `<div class="text-center text-red-400 p-8"><p class="beleren-font text-2xl">Errore Critico</p><p class="mt-2">${error}</p><p class="text-sm mt-2">Nota: Il caricamento diretto da mtgcardsmith.com potrebbe essere bloccato dal browser per motivi di sicurezza (CORS).</p></div>`;
        }
    }
    
    async function preloadScryfallSymbols() {
        try {
            const response = await fetch('https://api.scryfall.com/symbology');
            if (!response.ok) throw new Error(`API Scryfall per simbologia ha risposto con ${response.status}`);
            const result = await response.json();
            const symbolPromises = result.data.map(symbolData => {
                return new Promise(async (resolve) => {
                    try {
                        await new Promise(r => setTimeout(r, 50)); // Rate limit
                        const symbolImage = await loadImage(symbolData.svg_uri, true);
                        assets.symbols[symbolData.symbol] = symbolImage;
                    } catch (e) {
                         console.error(`Fallito il caricamento del simbolo: ${symbolData.symbol}`);
                    }
                    resolve();
                });
            });
            await Promise.all(symbolPromises);
        } catch (error) {
            console.error("Errore fatale nel caricare i simboli da Scryfall:", error);
            throw error;
        }
    }

    // --- Canvas Rendering ---

    async function renderCardOnCanvas(cardData, canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, CARD_WIDTH, CARD_HEIGHT);
        
        const getFrameAsset = (data) => {
            const isLegendary = data.type.toLowerCase().includes('leggendario') || data.type.toLowerCase().includes('leggendaria');
            const style = data.frame_style || 'Standard Colors';
            let key = data.colorIdentity + (isLegendary && style === 'Borderless' ? ' Legend' : '');
            return assets.frames[style]?.[key] || assets.frames['Standard Colors'][data.colorIdentity] || assets.frames['Standard Colors'].Artifact;
        };
        const getPtBoxAsset = (data) => {
            const style = data.frame_style === 'Borderless' ? 'Borderless' : 'Standard';
            return assets.ptBox[style]?.[data.colorIdentity] || assets.ptBox[style]?.Artifact;
        };

        const frame = getFrameAsset(cardData);
        const isBorderless = cardData.frame_style === 'Borderless';
        
        if (cardData.artImage?.complete) {
            const box = { x: 28, y: 55, w: 319, h: 236 };
            if (isBorderless) { Object.assign(box, { x: 0, y: 0, w: CARD_WIDTH, h: CARD_HEIGHT }); }
            const imgRatio = cardData.artImage.width / cardData.artImage.height;
            const boxRatio = box.w / box.h;
            let finalW, finalH, finalX, finalY;
            if (imgRatio > boxRatio) {
                finalH = box.h; finalW = finalH * imgRatio; finalX = box.x - (finalW - box.w) / 2; finalY = box.y;
            } else {
                finalW = box.w; finalH = finalW / imgRatio; finalX = box.x; finalY = box.y - (finalH - box.h) / 2;
            }
            ctx.save();
            ctx.beginPath();
            ctx.rect(box.x, box.y, box.w, box.h);
            ctx.clip();
            ctx.drawImage(cardData.artImage, finalX, finalY, finalW, finalH);
            ctx.restore();
        }

        if (frame?.complete) ctx.drawImage(frame, 0, 0, CARD_WIDTH, CARD_HEIGHT);

        ctx.save();
        ctx.fillStyle = isBorderless ? 'white' : 'black';
        if (isBorderless) {
            Object.assign(ctx, { shadowColor: 'rgba(0,0,0,0.8)', shadowBlur: 4, shadowOffsetX: 2, shadowOffsetY: 2 });
        }

        ctx.font = "bold 18px 'Beleren Smallcaps'";
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(cardData.name, 32, 40); 

        ctx.font = "bold 16px 'Beleren Smallcaps'";
        ctx.fillText(cardData.type, 32, 310);
        
        drawSetSymbol(ctx, cardData.rarity, 341, 310);
        
        ctx.fillStyle = isBorderless ? 'white' : 'black';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
        
        const { abilityText, flavorText } = separateTexts(cardData.text, cardData.flavorText);
        let textY = await drawTextWithMana(ctx, abilityText, 35, 346, 305, 18); 

        if (flavorText) {
            ctx.font = `italic 15px 'MPlantin'`;
            await drawTextWithMana(ctx, flavorText, 35, textY + 18, 305, 18);
        }

        await drawManaCost(ctx, cardData.manaCost, 345, 40);
        
        if (cardData.power && cardData.toughness && cardData.power !== 'null' && cardData.toughness !== 'null') {
            const ptBox = getPtBoxAsset(cardData);
            if (ptBox?.complete) ctx.drawImage(ptBox, 295, 470, 60, 30);
            Object.assign(ctx, { fillStyle: isBorderless ? 'white' : 'black', font: "bold 22px 'Beleren Smallcaps'", textAlign: 'center', textBaseline: 'middle' });
            ctx.fillText(`${cardData.power}/${cardData.toughness}`, 325, 485);
        }
        ctx.restore();
    }
    
    function separateTexts(ability, flavor) {
        return { abilityText: (ability || "").trim(), flavorText: (flavor || "").trim() };
    }

    async function drawManaCost(ctx, cost, x, y) {
        if (!cost) return;
        const symbols = cost.match(/\{[^{}]+\}/g) || [];
        let currentX = x;
        const symbolSize = 20;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let i = symbols.length - 1; i >= 0; i--) {
            const symbolImage = assets.symbols[symbols[i]];
            if (symbolImage?.complete) {
                ctx.drawImage(symbolImage, currentX - symbolSize, y - symbolSize/2, symbolSize, symbolSize);
                currentX -= (symbolSize + 2);
            }
        }
    }
    
    function drawSetSymbol(ctx, rarity, x, y) {
        const radius = 8, centerX = x - radius, centerY = y;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
        const rarityColors = { 'Uncommon': '#c0c0c0', 'Rare': '#ffd700', 'Mythic': '#ff4500' };
        ctx.fillStyle = rarityColors[rarity] || 'black';
        ctx.fill();
    }

    async function drawTextWithMana(ctx, text, x, y, maxWidth, initialLineHeight) {
        if (!text) return y;
        let fontSize = 15, lineHeight = 18;
        const calculateTextHeight = (txt, fSize, lHeight) => {
            ctx.font = `${fSize}px 'MPlantin'`;
            let tempY = 0, currentLineWidth = 0;
            const parts = txt.split(/(\{[^{}]+\}|\n|\s)/g);
            for (const part of parts) {
                if (!part) continue;
                if (part === '\n') { tempY += lHeight; currentLineWidth = 0; continue; }
                const partWidth = part.startsWith('{') ? fSize : ctx.measureText(part).width;
                if (currentLineWidth + partWidth > maxWidth && currentLineWidth > 0) {
                    tempY += lHeight; currentLineWidth = 0;
                }
                currentLineWidth += partWidth;
            }
            return tempY + lHeight;
        };
        while (fontSize > 10) {
            if (calculateTextHeight(text, fontSize, lineHeight) <= 120) break;
            fontSize -= 1;
            lineHeight = Math.floor(initialLineHeight * (fontSize / 15));
        }
        ctx.font = `${fontSize}px 'MPlantin'`;
        let currentX = x, currentY = y;
        const parts = text.split(/(\{[^{}]+\}|\n|\s)/g);
        for (const part of parts) {
            if (!part) continue;
            if (part === '\n') { currentX = x; currentY += lineHeight; continue; }
            if (part === ' ') { currentX += ctx.measureText(' ').width; continue; }
            const isSymbol = part.startsWith('{');
            const partWidth = isSymbol ? fontSize * 1.1 : ctx.measureText(part).width;
            if (currentX + partWidth > x + maxWidth && currentX > x) {
                currentX = x; currentY += lineHeight;
            }
            if (isSymbol) {
                const symbolImage = assets.symbols[part];
                if (symbolImage?.complete) {
                    ctx.drawImage(symbolImage, currentX, currentY - (fontSize*0.8), fontSize, fontSize);
                }
            } else {
                ctx.fillText(part, currentX, currentY);
            }
            currentX += partWidth;
        }
        return currentY;
    }

    // --- UI & Event Handlers ---

    function downloadCard(canvas, cardName) {
        const link = document.createElement('a');
        link.download = `${cardName.replace(/[ /\\?%*:|"<>]/g, '_')}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
    }

    const showLoading = (isLoading, message = "L'AI sta forgiando le carte...") => {
        loadingIndicator.classList.toggle('hidden', !isLoading);
        generationStatus.textContent = message;
        generateBtn.disabled = isLoading;
        stopBtn.classList.toggle('hidden', !isLoading);
        generateBtn.textContent = isLoading ? "Generazione..." : 'Genera Carte';
        generateBtn.classList.toggle('opacity-50', isLoading);
        generateBtn.classList.toggle('cursor-not-allowed', isLoading);
    };

    const showError = (message) => {
        errorMessage.textContent = message;
        errorMessage.classList.remove('hidden');
    }
    
    function createInlineEditForm(cardData, wrapper, cardIndex) {
        const form = document.createElement('div');
        form.className = 'edit-form space-y-2';
        form.innerHTML = `
            <div><label>Nome:</label><input type="text" value="${cardData.name || ''}"></div>
            <div><label>Costo:</label><input type="text" value="${cardData.manaCost || ''}"></div>
            <div><label>Tipo:</label><input type="text" value="${cardData.type || ''}"></div>
            <div><label>Testo:</label><textarea rows="3">${cardData.text || ''}</textarea></div>
            <div><label>Flavor:</label><textarea rows="2">${cardData.flavorText || ''}</textarea></div>
            <div class="grid grid-cols-2 gap-2">
                <div><label>Forza:</label><input type="text" value="${cardData.power || ''}"></div>
                <div><label>Cost.:</label><input type="text" value="${cardData.toughness || ''}"></div>
            </div>
            <div class="flex justify-end gap-2 pt-2">
                <button class="cancel-edit-btn bg-gray-600 hover:bg-gray-700 py-1 px-3 rounded text-sm">Annulla</button>
                <button class="save-edit-btn bg-green-600 hover:bg-green-700 py-1 px-3 rounded text-sm">Salva</button>
            </div>
        `;
        
        const canvas = wrapper.querySelector('canvas');

        form.querySelector('.save-edit-btn').addEventListener('click', () => {
            const inputs = form.querySelectorAll('input, textarea');
            const updatedCardData = generatedCards[cardIndex];
            
            updatedCardData.name = inputs[0].value;
            updatedCardData.manaCost = inputs[1].value;
            updatedCardData.type = inputs[2].value;
            updatedCardData.text = inputs[3].value;
            updatedCardData.flavorText = inputs[4].value;
            updatedCardData.power = inputs[5].value;
            updatedCardData.toughness = inputs[6].value;
            
            renderCardOnCanvas(updatedCardData, canvas);
            form.remove();
            canvas.style.display = 'block';
        });

        form.querySelector('.cancel-edit-btn').addEventListener('click', () => {
            form.remove();
            canvas.style.display = 'block';
        });

        return form;
    }

    async function regenerateArt(wrapper, cardIndex) {
        const cardData = generatedCards[cardIndex];
        const canvas = wrapper.querySelector('canvas');

        const loader = document.createElement('div');
        loader.className = 'card-loader';
        loader.innerHTML = '<svg class="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path></svg>';
        wrapper.prepend(loader);

        try {
            const artPrompt = `Magic: The Gathering card art, epic, high fantasy digital painting. Subject: ${cardData.artDescription}`;
            const imagePayload = { instances: [{ prompt: artPrompt }], parameters: { "sampleCount": 1 } };
            const imageResult = await robustFetch(`https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict`, imagePayload);
            if (imageResult.predictions?.[0]?.bytesBase64Encoded) {
                cardData.artImage = await loadImage(`data:image/png;base64,${imageResult.predictions[0].bytesBase64Encoded}`);
            }
            await renderCardOnCanvas(cardData, canvas);
        } catch (error) {
            console.error('Errore rigenerazione arte:', error);
            showError(`Errore rigenerazione arte per ${cardData.name}.`);
        } finally {
            loader.remove();
        }
    }
    
    // --- Main Generation Logic ---

    async function robustFetch(url, payload, retries = 3) {
        for (let i = 0; i < retries; i++) {
            try {
                // ** FIX: Correctly append API key for POST requests **
                const response = await fetch(`${url}?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (response.ok) return await response.json();
                if (response.status === 429) { // Too Many Requests
                    console.warn(`Rate limit hit. Tentativo ${i + 1}. Attendo...`);
                    await new Promise(res => setTimeout(res, 2000 * (i + 1))); // Exponential backoff
                } else {
                    throw new Error(`API Error: ${response.status}`);
                }
            } catch (error) {
                console.error(`Fetch fallito (tentativo ${i + 1}):`, error);
                if (i === retries - 1) throw error;
            }
        }
    }

    async function processCardQueue(cardElements, index) {
        if (index >= cardElements.length || isGenerationStopped) {
            showLoading(false, isGenerationStopped ? "Generazione interrotta." : "Generazione completata!");
            if (cardElements.length > 0 && !isGenerationStopped) bulkDownloadContainer.classList.remove('hidden');
            return;
        }

        const el = cardElements[index];
        showLoading(true, `Generando arte per "${el.cardData.name}" (${index + 1}/${cardElements.length})...`);
        
        try {
            const artPrompt = `Magic: The Gathering card art, epic, high fantasy digital painting. Subject: ${el.cardData.artDescription}`;
            const imagePayload = { instances: [{ prompt: artPrompt }], parameters: { "sampleCount": 1 } };
            const imageResult = await robustFetch(`https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict`, imagePayload);
            
            if (imageResult.predictions?.[0]?.bytesBase64Encoded) {
                el.cardData.artImage = await loadImage(`data:image/png;base64,${imageResult.predictions[0].bytesBase64Encoded}`);
            }
        } catch (imgError) {
            console.error(`Errore generazione immagine per ${el.cardData.name}:`, imgError);
            el.wrapper.innerHTML += `<p class="text-red-400 text-xs text-center">Errore Immagine</p>`;
        }

        await renderCardOnCanvas(el.cardData, el.canvas);
        el.loadingAnimation.remove();
        
        setTimeout(() => processCardQueue(cardElements, index + 1), 500);
    }

    generateBtn.addEventListener('click', async () => {
        isGenerationStopped = false;
        const theme = document.getElementById('set-theme').value;
        const count = document.getElementById('card-count').value;
        if (!theme) { showError('Per favore, inserisci un tema per il set.'); return; }
        
        showLoading(true, `Recupero i dati per ${count} carte...`);
        cardDisplayArea.innerHTML = '';
        errorMessage.classList.add('hidden');
        bulkDownloadContainer.classList.add('hidden');
        generatedCards = []; // Reset the in-memory store

        const textGenPrompt = `Crea ${count} carte di Magic: The Gathering con tema "${theme}". Non creare carte di tipo Terra. La maggior parte delle carte deve essere monocolore. Per ogni carta, fornisci un oggetto JSON con: name, manaCost, colorIdentity (uno tra 'White', 'Blue', 'Black', 'Red', 'Green', 'Gold', 'Artifact', 'Colorless'), rarity (uno tra 'Common', 'Uncommon', 'Rare', 'Mythic'), type (in italiano, includi 'leggendario' se appropriato), frame_style (uno tra 'Standard Colors', 'Borderless'), text (in italiano, con simboli mana tipo {sym} e \\n per a capo), flavorText (opzionale), power (per creature), toughness (per creature), artDescription (descrizione vivida per AI). Rispondi solo con un array di oggetti JSON.`;

        try {
            const textGenPayload = { 
                contents: [{ role: "user", parts: [{ text: textGenPrompt }] }],
                generationConfig: { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { type: "OBJECT", properties: { "name": { "type": "STRING" }, "manaCost": { "type": "STRING" }, "colorIdentity": { "type": "STRING" }, "rarity": { "type": "STRING" }, "type": { "type": "STRING" }, "frame_style": { "type": "STRING" }, "text": { "type": "STRING" }, "flavorText": { "type": "STRING" }, "power": { "type": "STRING" }, "toughness": { "type": "STRING" }, "artDescription": { "type": "STRING" } }, required: ["name", "manaCost", "colorIdentity", "rarity", "type", "frame_style", "text", "artDescription"] } } }
            };
            const textResult = await robustFetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent`, textGenPayload);
            generatedCards = JSON.parse(textResult.candidates[0].content.parts[0].text);

            const cardElements = generatedCards.map((cardData, i) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'card-wrapper';
                wrapper.dataset.cardIndex = i; // Use index to reference in-memory array

                const canvas = document.createElement('canvas');
                canvas.width = CARD_WIDTH;
                canvas.height = CARD_HEIGHT;
                
                const loadingAnimation = wrapper.appendChild(document.createElement('div'));
                loadingAnimation.className = 'card-loader';
                loadingAnimation.innerHTML = '<svg class="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path></svg>';
                
                const buttonGroup = document.createElement('div');
                buttonGroup.className = 'flex flex-wrap justify-center gap-2 mt-2';
                
                const downloadButton = document.createElement('button');
                downloadButton.innerHTML = 'Scarica';
                downloadButton.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded-lg text-xs';
                downloadButton.onclick = () => downloadCard(canvas, generatedCards[i].name);

                const editButton = document.createElement('button');
                editButton.innerHTML = 'Modifica';
                editButton.className = 'bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-lg text-xs';
                editButton.onclick = () => {
                    const cardIndex = parseInt(wrapper.dataset.cardIndex);
                    const currentCardData = generatedCards[cardIndex];
                    const form = createInlineEditForm(currentCardData, wrapper, cardIndex);
                    canvas.style.display = 'none';
                    wrapper.insertBefore(form, buttonGroup);
                };

                const regenArtButton = document.createElement('button');
                regenArtButton.innerHTML = 'Rigenera Arte';
                regenArtButton.className = 'bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-1 px-3 rounded-lg text-xs';
                regenArtButton.onclick = () => regenerateArt(wrapper, parseInt(wrapper.dataset.cardIndex));

                buttonGroup.append(downloadButton, editButton, regenArtButton);
                wrapper.append(canvas, buttonGroup);
                cardDisplayArea.appendChild(wrapper);
                return { wrapper, canvas, cardData, loadingAnimation };
            });

            processCardQueue(cardElements, 0);

        } catch (error) {
            console.error('Errore durante la generazione:', error);
            showError(`Si è verificato un errore: ${error.message}.`);
            showLoading(false);
        }
    });
    
    document.addEventListener('DOMContentLoaded', preloadAssets);
    stopBtn.addEventListener('click', () => { isGenerationStopped = true; });
    bulkDownloadBtn.addEventListener('click', () => {
        const zip = new JSZip();
        generatedCards.forEach((cardData, i) => {
            const wrapper = cardDisplayArea.querySelector(`[data-card-index='${i}']`);
            if (wrapper) {
                const canvas = wrapper.querySelector('canvas');
                const dataURL = canvas.toDataURL('image/png');
                zip.file(`${cardData.name.replace(/[ /\\?%*:|"<>]/g, '_')}.png`, dataURL.split(',')[1], {base64: true});
            }
        });
        zip.generateAsync({type:"blob"}).then(content => {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(content);
            link.download = "carte_generate.zip";
            link.click();
        });
    });

</script>
</body>
</html>
