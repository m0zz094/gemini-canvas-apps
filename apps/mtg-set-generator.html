<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Generatore Set Magic (Generazione Stabile)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
      @font-face {
        font-family: "Beleren Smallcaps";
        src: url("https://github.com/Hakkura/Magic-Fonts/raw/main/fonts/belerensmallcaps-bold.ttf")
          format("truetype");
        font-weight: bold;
        font-display: swap;
      }
      @font-face {
        font-family: "MPlantin";
        src: url("https://github.com/Hakkura/Magic-Fonts/raw/main/fonts/mplantin.ttf")
          format("truetype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }
      @font-face {
        font-family: "MPlantin";
        src: url("https://github.com/Hakkura/Magic-Fonts/raw/main/fonts/mplantin-italic.ttf")
          format("truetype");
        font-weight: normal;
        font-style: italic;
        font-display: swap;
      }

      body {
        font-family: "MPlantin", "Inter", sans-serif;
        background-color: #111827;
      }
      .beleren-font {
        font-family: "Beleren Smallcaps", sans-serif;
      }
      .card-wrapper {
        width: 100%;
        max-width: 300px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        position: relative;
      }
      .card-wrapper canvas {
        width: 100%;
        height: auto;
        border-radius: 4.75%;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s ease;
      }
      .card-wrapper canvas:hover {
        transform: scale(1.05) rotateZ(1deg);
      }
      #initial-loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(17, 24, 39, 0.95);
        z-index: 100;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow-y: auto;
      }
      .card-loader {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(31, 41, 55, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4.75%;
      }

      /* Modal per visualizzazione carte a grandezza intera */
      .card-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }
      .card-modal.active {
        opacity: 1;
        visibility: visible;
      }
      .card-modal-content {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        width: auto;
        height: auto;
      }
      .card-modal canvas {
        max-width: min(90vw, 488px);
        max-height: min(90vh, 680px);
        border-radius: 4.75%;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.8);
        display: block;
        object-fit: contain;
        width: auto;
        height: auto;
      }
      .card-modal-close {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.9);
        border: none;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        cursor: pointer;
        font-size: 18px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #loading-indicator {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 50;
        background-color: rgba(17, 24, 39, 0.9);
        backdrop-filter: blur(4px);
        padding: 0.75rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      }
      @media (min-width: 768px) {
        #loading-indicator {
          position: static;
          background-color: transparent;
          backdrop-filter: none;
          padding: 0;
          box-shadow: none;
        }
        #loading-indicator.desktop-sticky {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          background-color: rgba(17, 24, 39, 0.9);
          backdrop-filter: blur(4px);
          padding: 0.75rem;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
      }
      .edit-form {
        width: 100%;
        background-color: #1f2937;
        border-radius: 14px; /* Corrisponde a 4.75% di 300px */
        padding: 1rem;
        border: 2px solid #4b5563;
      }
      .edit-form input,
      .edit-form textarea {
        background-color: #374151;
        color: #f3f4f6;
        width: 100%;
        padding: 0.5rem;
        border-radius: 0.375rem;
        border: 1px solid #4b5563;
      }
      .edit-form label {
        font-size: 0.875rem;
        color: #9ca3af;
      }

      /* Stili per Booster Pack */
      .booster-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
        z-index: 2000;
        display: none;
        overflow: hidden;
      }

      .booster-pack {
        width: 200px;
        height: 280px;
        background: linear-gradient(145deg, #2d4a87, #1e3a5f);
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        cursor: pointer;
        position: relative;
        margin: 20px auto;
        border: 3px solid #ffd700;
      }

      .booster-pack::before {
        content: "";
        position: absolute;
        top: 10px;
        left: 10px;
        right: 10px;
        bottom: 10px;
        background: repeating-linear-gradient(
          45deg,
          rgba(255, 215, 0, 0.1),
          rgba(255, 215, 0, 0.1) 10px,
          transparent 10px,
          transparent 20px
        );
        border-radius: 10px;
      }

      .pack-label {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: #ffd700;
        font-family: "Beleren Smallcaps", sans-serif;
        font-size: 18px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      }

      .cards-reveal-area {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
        padding: 20px;
        max-width: 1200px;
        margin: 0 auto;
        min-height: 100vh;
      }

      .booster-card {
        width: 120px;
        height: auto;
        border-radius: 8px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        transform: rotateY(180deg) scale(0);
        opacity: 0;
        cursor: pointer;
        transition: transform 0.3s ease;
      }

      .booster-card:hover {
        transform: rotateY(0deg) scale(1.05);
      }

      .booster-card.revealed {
        transform: rotateY(0deg) scale(1);
        opacity: 1;
      }

      .close-booster {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.9);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        cursor: pointer;
        font-size: 20px;
        font-weight: bold;
        z-index: 2001;
      }

      .booster-title {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: #ffd700;
        font-family: "Beleren Smallcaps", sans-serif;
        font-size: 24px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        z-index: 2001;
      }
    </style>
  </head>
  <body class="bg-gray-900 text-white">
    <div id="initial-loading-overlay">
      <div class="text-center">
        <svg
          class="animate-spin h-10 w-10 text-white mx-auto"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
        >
          <circle
            class="opacity-25"
            cx="12"
            cy="12"
            r="10"
            stroke="currentColor"
            stroke-width="4"
          ></circle>
          <path
            class="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          ></path>
        </svg>
        <p id="loading-text" class="mt-4 text-xl text-gray-300 beleren-font">
          Caricamento Asset e Font...
        </p>
      </div>
    </div>

    <div class="container mx-auto px-4 py-8">
      <header class="text-center mb-12">
        <h1
          class="beleren-font text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-yellow-300 via-orange-400 to-red-500"
        >
          Generatore di Set MTG
        </h1>
        <p class="text-gray-400 mt-2">
          Crea carte di Magic ad alta fedelt√†, pronte per essere scaricate e
          stampate.
        </p>
      </header>

      <div
        class="max-w-2xl mx-auto bg-gray-800/50 backdrop-blur-sm rounded-xl shadow-2xl p-8 mb-12"
      >
        <div class="space-y-6">
          <div>
            <label
              for="generation-mode"
              class="block text-lg font-medium text-gray-300 mb-2"
              >Modalit√† di Generazione</label
            >
            <select
              id="generation-mode"
              class="w-full bg-gray-700 text-white rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500"
            >
              <option value="single">Carte Singole</option>
              <option value="set">Set Completo</option>
              <option value="commander">Mazzo Commander</option>
            </select>
          </div>
          <div>
            <label
              for="set-theme"
              class="block text-lg font-medium text-gray-300 mb-2"
              >Tema del Set o Carta Specifica</label
            >
            <input
              type="text"
              id="set-theme"
              class="w-full bg-gray-700 text-white rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500"
              placeholder="Es. Un planeswalker che controlla i sogni..."
            />
          </div>
          <div id="color-selector-container">
            <label class="block text-lg font-medium text-gray-300 mb-2"
              >Colori</label
            >
            <div id="color-selector" class="flex justify-center space-x-2">
              <!-- Le icone dei colori verranno inserite qui dal JS -->
            </div>
          </div>
          <div>
            <label
              for="card-count"
              class="block text-lg font-medium text-gray-300 mb-2"
              >Numero di Carte da Generare</label
            >
            <input
              type="number"
              id="card-count"
              class="w-full bg-gray-700 text-white rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500"
              value="20"
              min="1"
              max="300"
            />
          </div>
        </div>
        <div class="mt-8 text-center">
          <button
            id="generate-btn"
            disabled
            class="beleren-font bg-gray-500 cursor-not-allowed text-white font-bold py-3 px-10 rounded-lg shadow-lg transition-all duration-300"
          >
            Caricamento...
          </button>
          <button
            id="stop-btn"
            class="hidden beleren-font bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-10 rounded-lg shadow-lg transition-all duration-300"
          >
            Interrompi Generazione
          </button>
        </div>
      </div>

      <div id="bulk-download-container" class="hidden text-center my-6">
        <button
          id="bulk-download-btn"
          class="beleren-font bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-lg mr-4"
        >
          Scarica Tutte le Carte (.zip)
        </button>
        <button
          id="open-booster-btn"
          class="beleren-font bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-lg shadow-lg"
        >
          üéÅ Apri Booster Pack
        </button>
      </div>

      <div id="loading-indicator" class="hidden text-center my-10">
        <div class="flex items-center justify-center">
          <svg
            class="animate-spin h-8 w-8 text-white mr-3"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <circle
              class="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              stroke-width="4"
            ></circle>
            <path
              class="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
          </svg>
          <div>
            <p id="generation-status" class="text-gray-300">
              L'AI sta forgiando le carte...
            </p>
            <p id="time-estimation" class="text-gray-400 text-sm"></p>
          </div>
        </div>
      </div>

      <div
        id="error-message"
        class="hidden text-center my-10 bg-red-500/20 text-red-300 p-4 rounded-lg"
      ></div>

      <!-- Area per mostrare la meccanica del set -->
      <div
        id="set-mechanic-display"
        class="hidden mx-auto mb-8 p-6 bg-gradient-to-r from-purple-900/30 to-blue-900/30 rounded-lg border border-purple-500/30 max-w-4xl"
      >
        <h3
          class="text-xl font-bold text-purple-300 mb-3 beleren-font text-center"
        >
          Meccanica del Set
        </h3>
        <div class="bg-black/20 p-4 rounded-lg">
          <h4
            id="mechanic-name"
            class="text-lg font-bold text-yellow-300 mb-2"
          ></h4>
          <p id="mechanic-description" class="text-gray-300 mb-3"></p>
          <div class="text-sm text-gray-400">
            <strong>Flavor:</strong> <span id="mechanic-flavor"></span>
          </div>
        </div>
      </div>

      <div
        id="card-display-area"
        class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-8 justify-items-center"
      ></div>
    </div>

    <!-- Modal per visualizzazione carte a grandezza intera -->
    <div id="card-modal" class="card-modal">
      <div class="card-modal-content">
        <button class="card-modal-close" onclick="closeCardModal()">
          &times;
        </button>
        <canvas id="modal-canvas" width="745" height="1040"></canvas>
      </div>
    </div>

    <!-- Booster Pack Container -->
    <div id="booster-container" class="booster-container">
      <div class="booster-title">Apri il tuo Booster Pack!</div>
      <button class="close-booster" onclick="closeBooster()">&times;</button>

      <div
        id="pack-selection"
        class="cards-reveal-area"
        style="justify-content: center; align-items: center"
      >
        <div class="booster-pack" onclick="openPack()">
          <div class="pack-label">
            <div>BOOSTER PACK</div>
            <div style="font-size: 14px; margin-top: 5px">15 Carte</div>
          </div>
        </div>
      </div>

      <div
        id="cards-reveal-area"
        class="cards-reveal-area"
        style="display: none"
      >
        <!-- Le carte del booster appariranno qui -->
      </div>
    </div>

    <script>
      // Elements
      const generateBtn = document.getElementById("generate-btn");
      const stopBtn = document.getElementById("stop-btn");
      const bulkDownloadContainer = document.getElementById(
        "bulk-download-container"
      );
      const bulkDownloadBtn = document.getElementById("bulk-download-btn");
      const openBoosterBtn = document.getElementById("open-booster-btn");
      const loadingIndicator = document.getElementById("loading-indicator");
      const generationStatus = document.getElementById("generation-status");
      const timeEstimation = document.getElementById("time-estimation");
      const cardDisplayArea = document.getElementById("card-display-area");
      const errorMessage = document.getElementById("error-message");
      const initialLoadingOverlay = document.getElementById(
        "initial-loading-overlay"
      );
      const generationModeSelect = document.getElementById("generation-mode");
      const colorSelectorContainer = document.getElementById(
        "color-selector-container"
      );
      const colorSelector = document.getElementById("color-selector");
      const cardCountInput = document.getElementById("card-count");

      // State
      let isGenerationStopped = false;
      let generatedCards = [];
      let generationTimeoutId = null;
      let generationStartTime = 0;
      let loadingIndicatorOriginalTop = 0;

      // Constants
      const CARD_WIDTH = 375;
      const CARD_HEIGHT = 523;
      const assets = { frames: {}, ptBox: {}, symbols: {}, loyalty: {} };
      const MTG_CARDSMITH_BASE = "https://mtgcardsmith.com";
      const FRAME_ASSETS = {
        "Standard Colors": {
          White: "/moderator/thumb/custom_666b5f5b0a7b2.jpg?v=1",
          Blue: "/moderator/thumb/custom_666b66c13041d.jpg?v=1",
          Black: "/moderator/thumb/custom_666b62e1659a8.jpg?v=1",
          Red: "/moderator/thumb/custom_666b637f49d3c.jpg?v=1",
          Green: "/moderator/thumb/custom_666b647f32017.jpg?v=1",
          Artifact: "/moderator/thumb/custom_666b64b05d996.jpg?v=1",
          Colorless: "/moderator/thumb/custom_666b64d958319.jpg?v=1",
          Land: "/moderator/thumb/custom_666b64d958319.jpg?v=1",
          Gold: "/moderator/thumb/custom_666ba621b8c9d.png?v=1",
        },
        Borderless: {
          White: "/moderator/thumb/custom_66637c40bf2a2.png?v=1",
          "White Legend": "/moderator/thumb/custom_666389e5e46a1.png?v=1",
          Blue: "/moderator/thumb/custom_6663822aa3c55.png?v=1",
          "Blue Legend": "/moderator/thumb/custom_666382be85178.png?v=1",
          Black: "/moderator/thumb/custom_6663830c90efd.png?v=1",
          "Black Legend": "/moderator/thumb/custom_666383273f96e.png?v=1",
          Red: "/moderator/thumb/custom_6663833f965ba.png?v=1",
          "Red Legend": "/moderator/thumb/custom_66638376b7b51.png?v=1",
          Green: "/moderator/thumb/custom_666388ec7e198.png?v=1",
          "Green Legend": "/moderator/thumb/custom_666389293baab.png?v=1",
          Gold: "/moderator/thumb/custom_66638b4a98a6e.png?v=1",
          "Gold Legend": "/moderator/thumb/custom_66638b876689f.png?v=1",
          Artifact: "/moderator/thumb/custom_66638ba07c65e.png?v=1",
          "Artifact Legend": "/moderator/thumb/custom_66638bcd6c326.png?v=1",
          Land: "/moderator/thumb/custom_66638ca862a35.png?v=1",
          "Land Legend": "/moderator/thumb/custom_66638ce7c7962.png?v=1",
          Colorless: "/moderator/thumb/custom_66638d05e06de.png?v=1",
          "Colorless Legend": "/moderator/thumb/custom_66638d29593a9.png?v=1",
        },
        Planeswalker: {
          White: "/view/images/cards/planes/wcard.png",
          Red: "/view/images/cards/planes/rcard.png",
          Green: "/view/images/cards/planes/gcard.png",
          Black: "/view/images/cards/planes/bcard.png",
          Blue: "/view/images/cards/planes/ucard.png",
          Gold: "/view/images/cards/planes/omcard.png",
          Artifact: "/view/images/cards/planes/acard.png",
        },
      };
      const PT_BOX_ASSETS = {
        Standard: {
          Black: "/moderator/ptImgs/custom_66638540b2307.png",
          White: "/moderator/ptImgs/custom_666383e4ba24e.png",
          Blue: "/moderator/ptImgs/custom_66638454b50c0.png",
          Red: "/moderator/ptImgs/custom_6663850c4c508.png",
          Green: "/moderator/ptImgs/custom_6663851f571d5.png",
          Artifact: "/moderator/ptImgs/custom_66638535808c3.png",
          Colorless: "/moderator/ptImgs/custom_66638540b2307.png",
          Gold: "/moderator/ptImgs/custom_66576b60da360.png",
        },
        Borderless: {
          Black: "/moderator/ptImgs/custom_6663824ab6918.png",
          White: "/moderator/ptImgs/custom_6663811764b39.png",
          Blue: "/moderator/ptImgs/custom_66638241c552b.png",
          Red: "/moderator/ptImgs/custom_6663824f56d90.png",
          Green: "/moderator/ptImgs/custom_6663825ebab9f.png",
          Artifact: "/moderator/ptImgs/custom_66638267b0ce4.png",
          Colorless: "/moderator/ptImgs/custom_6663827878b84.png",
          Gold: "/moderator/ptImgs/custom_666382623fb86.png",
        },
      };
      const ITALIAN_KEYWORDS = [
        "Attacco improvviso",
        "Cautela",
        "Difensore",
        "Doppio attacco",
        "Incanta",
        "Equipaggia",
        "Lampo",
        "Volare",
        "Rapidit√†",
        "Intimidire",
        "Indistruttibile",
        "Legame vitale",
        "Protezione",
        "Raggiungere",
        "Travolgere",
        "Passa-isole",
        "Passa-foreste",
        "Passa-montagne",
        "Passa-paludi",
        "Anti-malocchio",
        "Furtivit√†",
        "Ombra",
        "Rigenerare",
        "Attacco letale",
        "Velo",
      ];
      const LOYALTY_PLUS_B64 =
        "data:image/webp;base64,UklGRkoDAABXRUJQVlA4WAoAAAAQAAAAHQAAFwAAQUxQSGIBAAANkKVtk2k7X3WtvWLbtjED48q2MyDbyQSc3Nm2bTtZq7qOzxpCREwANQxitEufoR6pvXrurWdM9oP7XxAkeo0kmDFw+Shg9bgTGy85Gr2aIHnUcSu7QB7EWs1c/mH9gb+ox0qaebOZSwALJVCPydhVnXfsfUdwB+u9ZBJEV6WyBEyGLBt1dMsNkKZr+oNJItRQid5+zrynqz+4TiBLEmobxK3BmINW7/PdoQlFCn4aadTwUQMvBOQZoX7j5ylFv0A0/UPhP8FcpTAg9wYU3vQrMbQurtcDj42aI8UIQ+7+zvvioZjgvRpd9UleFCYrN06F4C4gNXJwUhZ9iCf7N1ehslcjCAj/7x8feftsXmrVqmXDBnUTqQb78+vH6zsnX4H8//jlw9dvmYUkLZUClv3/+89cGzbr2bLu/1c/LKmjWPbnX5ZlhqiW0jqpJvXqp8r7n38tukjQEERwokePjtatqwJWUDggwgEAAPALAJ0BKh4AGAA+MRaIQqIhIRgMBAAgAwS0gGGdvr/mfKIeo2T1aZvyAz0DJUf4D8jNRG1Ev+q+0D4zf7fzbfMv+n9hz+gf4T8w+Mg/W4QhZz0zgcFgW8j7FJ8xcT2sQ4DhFXsLx7YAAP77vhqXkTNnZi+TiEU41iJP7VFRwe1keWfsUMwOjohAO/oo8Uh86Oy9o9Ox8nK/Dg+znRvCeMVOFZkEUY7V2+w2vZNn2FIl28w//fdpTO1t79zvO5gUYKBviSErt9LxVsMbsbEeofvXavb7NQeHG76fFOJq3TwDf9ZdxdSdw8Kh8T2iekHp1/j2GPhcfWmkTsoAaglhBUGfS/ouczouf1m+mDsHChcPi9h2f6vgE+MrCaOf/uUDIHwoGFbID2FI//tBndyWhyD3Y89jKUcA6DjfYv38rNNXe+IV/mXnZv6apPL5a8pbQ91Qlrnc1w6rbFVJj/Fh/ICINFray/ApK/EbbtjdvdB+jLxjpkMjxKle6+vHZ03FXxxK9jkT9/I/zv2lCaXUG14RXFPhD/9zNXzD7HUZafqPKPCtMxE5uO+XvO8Z5ex9/B6Cdb28huDUni+wk8AGkAAAAA==";
      const LOYALTY_MINUS_B64 =
        "data:image/webp;base64,UklGRkoDAABXRUJQVlA4WAoAAAAQAAAAHQAAFwAAQUxQSHYBAAANkBzbtmora51r3598d9ydlpMDCZCN9skAetAjAHd3d3e/es7e2H2cECJiAmCMOtTGCYsCtQFFIAKMzJlYMNVoNaJAxX798uXlg1dP3jgFopltG9Z3o8Pu3kazOblgollcPn3kyfadAKCiIIi/FQqa1uzaDVt3Hp5ZJiGNIeoJAlB1vH8TB3bALwmzF0uO9/QrfUDD72fQzJ+NwK/yhmGFL8NKT3cRfINrwfdT8Cei2FsKlBIbb1EFiwa8j7yDcsjf3MciA31KP3TLn/7UMQUV/C/VkDPFq+5X+7ctSaBgR6oBfx7cZ6jVk+tfF65oA8oaoeHno4e6AWQ/EX2993xk1TQhJFSNwbNTd4aXDJUVfnz95noa7tGDYNWiBIKA7ubxD/NWjCURgTz9nlrtakSv73xfvLyJ7xdOm2ULExdHBCCuyNOsknCg98udZ5P2anvlJDWJDP6pam2eZqU1vb0/zv1Y0xZ2hUSnIrbI06KSMAlsGAdEPVZQOCCuAQAAUAoAnQEqHgAYAD4xFIhCoiEhFAaoIAMEtIBjfb6f5h9AFuA+233bMzfjvksP7T+Ts+b/0Xlx+gP+R7gX6e/5v8sjCHb+97M+E4g9oh4IVkUlpRZH9PPEnT6XAAD+/hJmZeZ/P5vlW2yLEitPLTvUDtKW/Pc8h19dv87GRnar8XbnQnFMJRbHwwxnuovcVmu+5f+b6/Ljlh220BHMI03u2YxsyP3U+ytyjlXnWHUZoolkkeT6LX2LtWxYk6m9V5+sbYVM6/bIP10dQvZI7hoM/WGCkzTb2PY5hssf6Oy5afa+811NdwuGI8FVF+aNI/k/8c9NyNp0ZEB93+ehmv7VQyDpQ/Ebqk4t+D68T/t8TXg8z5qVNJ6hlaUpwpBXBYOLY23zFZJSx1QWWfkyiwbJcvyITJYPsXGo60QStfSoCCQ0+4zd8G0tU/qDyta+dB+lG/T9FajYxHWDnt/vYNaiy1rb28zqDiqebvjluabAbUnKIKTEXifoZhMxU7NNCRLNBFMd+mtURurIrcyq5fQJ3Zr0zvPeTk1LZ4YEWIN54ZouIRuLAtUscQ+4LgAAAA==";
      const LOYALTY_ZERO_B64 =
        "data:image/webp;base64,UklGRi4DAABXRUJQVlA4WAoAAAAQAAAAHQAAFwAAQUxQSGwBAAANkFtbmyI531fVXbXMzLzeipmZU5AtS0koBc5CRzZaMpmZmbFhpv7fGOoQImICUEmSUFFUNQZQFVTSMIiqAnA+ZjlPRFBpoQIVRd/0wuTUUFerjSAh//Ht1cvnT9/kADi4due6XtTpmju7eyenZkZx6+rVJ3rsIAAVBUEQUCgUpnV85faeo+PnloZojCFqEgQB1bI9gbns/HpBkVR3/7ntGbjpbSFQXoyctqb/WpRFELfj8McaaUGhJryy+AbnfCHK7Bf4P0TeFAJoDgShR8FOSwgatxRD8X0fyNBBsAiIWXmDcWkCYgohjlzQ2C+qQaEmbEqvR3sAaAXr0CrGnjw++OjNWJurqJcV4dO1l779+ZtMXVtrk3fWkIBoKGXJ36/PHpcNsxCyPE2ScllAAKoioHVNnaND/Pn+bwrnoggMGiAKglQpa+RbWu2b30kQ0BhaEoSoSFCF9R0dMX8kWR7KElRVUdUYY2wceW8JVlA4IJwBAABwCwCdASoeABgAPjEUiEKiISEYBAAgAwS0gAiIngAauF71+NeiM/qWSQer35Aaoh/ZtYA/pv+k9LjPv8pf6L3Bv4t/Rv8T+Z39l5FX9gB48QPGWDonxs5uqiGsiatCRyGQ9yFsAP7h9awLeCe/zFfTR5dTHpNtMTDfdd2nqPDTP35f9nz/UC5z+g/ccx/0Bo2U9n6Q9x4d3LGYZJ/1WRmLtb8Teqp2y7QUN1+Gs184rjZP9ODg/ugB/B8YVsExp6+Lrg15rdZItKs0f34okT75myt+iwJW79xb+V8ynmcG1h/2jX//hvE1g+I0JzkNltY4J+wPat546tCXr/8AJUv/gUftO8Cg6XH55OTrz6W/8v5SazTPcBNG3ox9H2nC6u2DAwQENiYllp19xiq6EMTc7++YlS/of72kB7uXLKJ7voqYCML3UAlsfrGM35niYE3PhKM6Cbzf5RtmADNZ2JiCpT5hfv6uWYgh/7Ycc/8ED43CVRWpa6yqHf54PrYH7nM3pfd6+/Rv55bib62Z50piURS7OFP0AEWhIAAA";
      const apiKey = ""; // Gestita dall'ambiente

      // Simboli di lealt√† per i planeswalker
      const LOYALTY_SYMBOLS = {
        plus: LOYALTY_PLUS_B64,
        minus: LOYALTY_MINUS_B64,
        zero: LOYALTY_ZERO_B64,
      };

      // --- Asset & Core Functions ---

      function loadImage(src) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "Anonymous";
          img.onload = () => resolve(img);
          img.onerror = (e) =>
            reject(`Impossibile caricare l'asset da ${src}. Errore: ${e}`);
          img.src = src;
        });
      }

      async function preloadAssets() {
        const assetPromises = [];
        for (const style in FRAME_ASSETS) {
          if (!assets.frames[style]) assets.frames[style] = {};
          for (const color in FRAME_ASSETS[style]) {
            const url = MTG_CARDSMITH_BASE + FRAME_ASSETS[style][color];
            assetPromises.push(
              loadImage(url)
                .then((img) => {
                  assets.frames[style][color] = img;
                })
                .catch((e) => console.warn(e))
            );
          }
        }
        for (const style in PT_BOX_ASSETS) {
          if (!assets.ptBox[style]) assets.ptBox[style] = {};
          for (const color in PT_BOX_ASSETS[style]) {
            const url = MTG_CARDSMITH_BASE + PT_BOX_ASSETS[style][color];
            assetPromises.push(
              loadImage(url)
                .then((img) => {
                  assets.ptBox[style][color] = img;
                })
                .catch((e) => console.warn(e))
            );
          }
        }

        // Carica i simboli di lealt√† per i planeswalker
        assets.loyalty = {}; // Inizializza l'oggetto loyalty
        for (const symbol in LOYALTY_SYMBOLS) {
          assetPromises.push(
            loadImage(LOYALTY_SYMBOLS[symbol])
              .then((img) => {
                assets.loyalty[symbol] = img;
                console.log(`Simbolo lealt√† caricato: ${symbol}`);
              })
              .catch((e) =>
                console.error(`Errore caricamento simbolo ${symbol}:`, e)
              )
          );
        }

        try {
          await Promise.all([
            ...assetPromises,
            document.fonts.ready,
            preloadScryfallSymbols(),
          ]);
          initialLoadingOverlay.style.display = "none";
          generateBtn.disabled = false;
          generateBtn.textContent = "Genera Carte";
          generateBtn.className =
            "beleren-font bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white font-bold py-3 px-10 rounded-lg shadow-lg transform hover:scale-105 transition-transform duration-300";
        } catch (error) {
          console.error(error);
          initialLoadingOverlay.innerHTML = `<div class="text-center text-red-400 p-8"><p class="beleren-font text-2xl">Errore Critico</p><p class="mt-2">${error}</p><p class="text-sm mt-2">Nota: Il caricamento diretto da mtgcardsmith.com potrebbe essere bloccato dal browser per motivi di sicurezza (CORS). Ricarica la pagina per riprovare.</p></div>`;
        }
      }

      async function preloadScryfallSymbols() {
        try {
          const response = await fetch("https://api.scryfall.com/symbology");
          if (!response.ok)
            throw new Error(
              `API Scryfall per simbologia ha risposto con ${response.status}`
            );
          const result = await response.json();
          const symbolPromises = result.data.map((symbolData) => {
            return new Promise(async (resolve) => {
              try {
                if (symbolData.svg_uri) {
                  await new Promise((r) => setTimeout(r, 50)); // Rate limit
                  const symbolImage = await loadImage(symbolData.svg_uri, true);
                  assets.symbols[symbolData.symbol] = symbolImage;
                }
              } catch (e) {
                console.warn(
                  `Fallito il caricamento del simbolo: ${symbolData.symbol}`
                );
              }
              resolve();
            });
          });
          await Promise.all(symbolPromises);
        } catch (error) {
          console.error(
            "Errore fatale nel caricare i simboli da Scryfall:",
            error
          );
          throw error;
        }
      }

      // --- Canvas Rendering ---

      function drawFittingText(ctx, text, initialFont, maxWidth) {
        if (!text) return initialFont;

        let fontSize = parseInt(initialFont.split("px")[0]);
        let fontStyle = initialFont.split("px")[1]; // es. " 'Beleren Smallcaps'"

        // Test iniziale
        ctx.font = initialFont;
        let textWidth = ctx.measureText(text).width;

        // Ridimensiona se necessario, partendo dal font size iniziale
        while (textWidth > maxWidth && fontSize > 6) {
          fontSize--;
          ctx.font = `${fontSize}px${fontStyle}`;
          textWidth = ctx.measureText(text).width;
        }

        // Se il testo √® ancora troppo lungo dopo aver raggiunto la dimensione minima
        if (textWidth > maxWidth && fontSize <= 6) {
          console.warn(`Testo troppo lungo per il rendering: "${text}"`);
        }

        return ctx.font;
      }

      async function renderCardOnCanvas(cardData, canvas) {
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, CARD_WIDTH, CARD_HEIGHT);

        // Assicurati che il colorIdentity sia sempre definito e corretto
        if (
          !cardData.colorIdentity ||
          cardData.colorIdentity === "DA_DETERMINARE_DA_MANA_COST" ||
          cardData.colorIdentity === ""
        ) {
          cardData.colorIdentity = determineColorIdentityFromManaCost(
            cardData.manaCost
          );
          console.log(
            `ColorIdentity aggiornato per ${cardData.name}: ${cardData.colorIdentity}`
          );
        }

        const isPlaneswalker =
          (cardData.type &&
            cardData.type.toLowerCase().includes("planeswalker")) ||
          cardData.startingLoyalty !== undefined ||
          (cardData.abilities && Array.isArray(cardData.abilities)) ||
          // Controllo pi√π specifico per abilit√† di loyalty nel testo
          (cardData.text &&
            (/^[+-]\d+:\s/.test(cardData.text.trim()) || // Inizia con +/- numero e due punti
              cardData.text.includes("\n+") || // Contiene newline seguita da +
              cardData.text.includes("\n-") || // Contiene newline seguita da -
              cardData.text.includes("\n0:"))); // Contiene newline seguita da 0:

        console.log(`Planeswalker detection for ${cardData.name}:`, {
          type: cardData.type,
          hasTypeKeyword: cardData.type?.toLowerCase().includes("planeswalker"),
          hasStartingLoyalty: cardData.startingLoyalty !== undefined,
          hasAbilities: cardData.abilities && Array.isArray(cardData.abilities),
          hasLoyaltyText:
            cardData.text &&
            (/^[+-]\d+:\s/.test(cardData.text.trim()) ||
              cardData.text.includes("\n+") ||
              cardData.text.includes("\n-") ||
              cardData.text.includes("\n0:")),
          finalDecision: isPlaneswalker,
        });

        // Forza SEMPRE il frame_style per i planeswalker, con controlli multipli
        if (isPlaneswalker) {
          cardData.frame_style = "Planeswalker";
          console.log(
            `FORZATO frame_style Planeswalker per: ${cardData.name}`,
            {
              hasType: cardData.type?.toLowerCase().includes("planeswalker"),
              hasLoyalty: cardData.startingLoyalty !== undefined,
              hasAbilities:
                cardData.abilities && Array.isArray(cardData.abilities),
              hasLoyaltyText:
                cardData.text &&
                cardData.text.includes(":") &&
                (cardData.text.includes("+") || cardData.text.includes("-")),
            }
          );
        }

        const getFrameAsset = (data) => {
          console.log("Getting frame asset for:", {
            name: data.name,
            isPlaneswalker: isPlaneswalker,
            frameStyle: data.frame_style,
            colorIdentity: data.colorIdentity,
            type: data.type,
          });

          if (isPlaneswalker) {
            console.log("Processing PLANESWALKER frame selection");

            // Prima prova con il frame specifico per planeswalker
            const planeswalkerFrame =
              assets.frames["Planeswalker"]?.[data.colorIdentity];
            console.log("Trying Planeswalker frame:", {
              colorIdentity: data.colorIdentity,
              frameExists: !!planeswalkerFrame,
              frameComplete: planeswalkerFrame?.complete,
            });

            if (planeswalkerFrame?.complete) {
              console.log(
                "‚úÖ Using Planeswalker frame for:",
                data.colorIdentity
              );
              return planeswalkerFrame;
            }

            // Se non esiste, usa Gold per multicolore
            if (
              data.colorIdentity === "Gold" &&
              assets.frames["Planeswalker"]?.Gold?.complete
            ) {
              console.log("‚úÖ Using Planeswalker Gold frame");
              return assets.frames["Planeswalker"].Gold;
            }

            // Prova White come fallback per i planeswalker
            if (assets.frames["Planeswalker"]?.White?.complete) {
              console.log("‚ö†Ô∏è Using Planeswalker White frame as fallback");
              return assets.frames["Planeswalker"].White;
            }

            console.warn(
              "‚ùå No Planeswalker frame available, falling back to Standard"
            );
          }

          const isLegendary =
            data.type.toLowerCase().includes("leggendario") ||
            data.type.toLowerCase().includes("leggendaria");
          const style = data.frame_style || "Standard Colors";
          let key =
            data.colorIdentity +
            (isLegendary && style === "Borderless" ? " Legend" : "");

          const primaryFrame = assets.frames[style]?.[key];
          if (primaryFrame?.complete) return primaryFrame;

          const fallbackFrame =
            assets.frames["Standard Colors"]?.[data.colorIdentity];
          if (fallbackFrame?.complete) return fallbackFrame;

          return assets.frames["Standard Colors"]?.Artifact;
        };
        const getPtBoxAsset = (data) => {
          const style =
            data.frame_style === "Borderless" ? "Borderless" : "Standard";
          return (
            assets.ptBox[style]?.[data.colorIdentity] ||
            assets.ptBox[style]?.Artifact
          );
        };

        const frame = getFrameAsset(cardData);

        // Debug e controllo frame - assicurati che sia sempre presente
        if (!frame || !frame.complete) {
          console.error("Frame non disponibile per carta:", {
            name: cardData.name,
            colorIdentity: cardData.colorIdentity,
            isPlaneswalker,
            frameStyle: cardData.frame_style,
            availableFrames: Object.keys(assets.frames),
          });
          // Fallback di emergenza
          const emergencyFrame = assets.frames["Standard Colors"]?.Artifact;
          if (emergencyFrame?.complete) {
            console.log("Usando frame di emergenza Artifact");
            Object.assign(cardData, { colorIdentity: "Artifact" });
          }
        }

        if (isPlaneswalker) {
          console.log("Planeswalker frame debug:", {
            name: cardData.name,
            colorIdentity: cardData.colorIdentity,
            frameFound: frame ? "Yes" : "No",
            frameComplete: frame?.complete ? "Yes" : "No",
            frameStyle: cardData.frame_style,
            manaCost: cardData.manaCost,
          });
        }

        const isBorderless = cardData.frame_style === "Borderless";

        if (cardData.artImage?.complete) {
          const box = { x: 28, y: 55, w: 319, h: 236 };
          if (isBorderless) {
            Object.assign(box, { x: 0, y: 0, w: CARD_WIDTH, h: CARD_HEIGHT });
          }
          // Per i planeswalker, l'arte dovrebbe occupare pi√π spazio come nelle borderless
          if (isPlaneswalker) {
            Object.assign(box, { x: 0, y: 0, w: CARD_WIDTH, h: CARD_HEIGHT }); // Area completa come borderless
          }

          const imgRatio = cardData.artImage.width / cardData.artImage.height;
          const boxRatio = box.w / box.h;
          let finalW, finalH, finalX, finalY;
          if (imgRatio > boxRatio) {
            finalH = box.h;
            finalW = finalH * imgRatio;
            finalX = box.x - (finalW - box.w) / 2;
            finalY = box.y;
          } else {
            finalW = box.w;
            finalH = finalW / imgRatio;
            finalX = box.x;
            finalY = box.y - (finalH - box.h) / 2;
          }
          ctx.save();
          ctx.beginPath();
          ctx.rect(box.x, box.y, box.w, box.h);
          ctx.clip();
          ctx.drawImage(cardData.artImage, finalX, finalY, finalW, finalH);
          ctx.restore();
        }

        if (frame?.complete)
          ctx.drawImage(frame, 0, 0, CARD_WIDTH, CARD_HEIGHT);

        ctx.save();
        ctx.fillStyle = isBorderless ? "white" : "black";
        if (isBorderless) {
          Object.assign(ctx, {
            shadowColor: "rgba(0,0,0,0.8)",
            shadowBlur: 4,
            shadowOffsetX: 2,
            shadowOffsetY: 2,
          });
        }

        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.font = drawFittingText(
          ctx,
          cardData.name,
          "bold 18px 'Beleren Smallcaps'",
          285 // Aumentato da 280 a 285
        );

        // Posizionamento condizionale: planeswalker 2px pi√π in alto
        const nameY = isPlaneswalker ? 32 : 40;
        ctx.fillText(cardData.name, 32, nameY);

        ctx.font = drawFittingText(
          ctx,
          cardData.type,
          "bold 16px 'Beleren Smallcaps'",
          285 // Aumentato da 280 a 285
        );
        ctx.fillText(cardData.type, 32, 310);

        drawSetSymbol(ctx, cardData.rarity, 341, 310);

        ctx.fillStyle = isBorderless ? "white" : "black";
        ctx.textAlign = "left";
        ctx.textBaseline = "alphabetic";
        if (isPlaneswalker) {
          // Rendering per planeswalker - abilit√† di lealt√† pi√π in basso
          await drawPlaneswalkerAbilities(
            ctx,
            cardData.text || "",
            21, // Altri 2px a sinistra (era 23)
            336, // 8px pi√π in alto (era 344)
            319 // Allargata per compensare i 2px aggiuntivi
          );

          // Disegna la lealt√† iniziale in basso a destra (fedele agli originali)
          if (cardData.startingLoyalty) {
            ctx.save();
            ctx.fillStyle = "white";
            ctx.font = "bold 24px 'Beleren Smallcaps'";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // Posizione come negli originali Magic
            const loyaltyX = 328; // 1px pi√π a destra
            const loyaltyY = 482; // 1px pi√π in su

            // Shadow/outline per leggibilit√†
            ctx.strokeStyle = "black";
            ctx.lineWidth = 3;
            ctx.strokeText(
              cardData.startingLoyalty.toString(),
              loyaltyX,
              loyaltyY
            );

            // Testo principale
            ctx.fillText(
              cardData.startingLoyalty.toString(),
              loyaltyX,
              loyaltyY
            );
            ctx.restore();
          }
        } else {
          // Rendering per carte normali
          await drawTextWithMana(ctx, cardData.text || "", 35, 346, 305, 18);

          // Power/Toughness per le creature
          if (
            cardData.power &&
            cardData.toughness &&
            cardData.power !== "null" &&
            cardData.toughness !== "null"
          ) {
            const ptBox = getPtBoxAsset(cardData);
            if (ptBox?.complete) ctx.drawImage(ptBox, 295, 470, 60, 30);
            Object.assign(ctx, {
              fillStyle: isBorderless ? "white" : "black",
              font: "bold 22px 'Beleren Smallcaps'",
              textAlign: "center",
              textBaseline: "middle",
            });
            ctx.fillText(`${cardData.power}/${cardData.toughness}`, 325, 485);
          }
        }

        // Posizionamento condizionale costo mana: planeswalker 4px pi√π in su rispetto alle carte standard
        const manaCostY = isPlaneswalker ? 34 : 38;
        await drawManaCost(ctx, cardData.manaCost, 345, manaCostY);
        ctx.restore();
      }

      async function drawManaCost(ctx, cost, x, y) {
        if (!cost) return;
        const symbols = cost.match(/\{[^{}]+\}/g) || [];
        let currentX = x;
        const symbolSize = 20;
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";
        for (let i = symbols.length - 1; i >= 0; i--) {
          const symbolImage = assets.symbols[symbols[i]];
          if (symbolImage?.complete) {
            ctx.drawImage(
              symbolImage,
              currentX - symbolSize,
              y - symbolSize / 2,
              symbolSize,
              symbolSize
            );
            currentX -= symbolSize + 2;
          }
        }
      }

      function drawSetSymbol(ctx, rarity, x, y) {
        const radius = 8;
        const centerX = x - radius;
        const centerY = y;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
        const rarityColors = {
          Uncommon: "#c0c0c0",
          Rare: "#ffd700",
          Mythic: "#ff4500",
        };
        ctx.fillStyle = rarityColors[rarity] || "black";
        ctx.fill();
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      async function drawTextWithMana(
        ctx,
        text,
        x,
        y,
        maxWidth,
        initialLineHeight
      ) {
        if (!text) return y;
        let fontSize = 15,
          lineHeight = 18;
        const calculateTextHeight = (txt, fSize, lHeight) => {
          ctx.font = `${fSize}px 'MPlantin'`;
          let tempY = 0,
            currentLineWidth = 0;
          const parts = txt.split(/(\{[^{}]+\}|\n|\s)/g);
          for (const part of parts) {
            if (!part) continue;
            if (part === "\n") {
              tempY += lHeight;
              currentLineWidth = 0;
              continue;
            }
            const partWidth = part.startsWith("{")
              ? fSize
              : ctx.measureText(part).width;
            if (
              currentLineWidth + partWidth > maxWidth &&
              currentLineWidth > 0
            ) {
              tempY += lHeight;
              currentLineWidth = 0;
            }
            currentLineWidth += partWidth;
          }
          return tempY + lHeight;
        };
        while (fontSize > 10) {
          if (calculateTextHeight(text, fontSize, lineHeight) <= 120) break;
          fontSize -= 1;
          // Riduzione pi√π aggressiva del line-height per evitare sovrapposizioni
          lineHeight = Math.max(
            14,
            Math.floor(initialLineHeight * (fontSize / 15) * 0.85)
          );
        }
        ctx.font = `${fontSize}px 'MPlantin'`;
        // Non impostiamo textBaseline qui, usiamo quello del contesto chiamante
        let currentX = x,
          currentY = y;
        const parts = text.split(/(\{[^{}]+\}|\n|\s)/g);
        for (const part of parts) {
          if (!part) continue;
          if (part === "\n") {
            currentX = x;
            currentY += lineHeight;
            continue;
          }
          if (part === " ") {
            currentX += ctx.measureText(" ").width;
            continue;
          }
          const isSymbol = part.startsWith("{");
          const partWidth = isSymbol
            ? fontSize * 1.1
            : ctx.measureText(part).width;
          if (currentX + partWidth > x + maxWidth && currentX > x) {
            currentX = x;
            currentY += lineHeight;
          }
          if (isSymbol) {
            const symbolImage = assets.symbols[part];
            if (symbolImage?.complete) {
              ctx.drawImage(
                symbolImage,
                currentX,
                currentY - fontSize * 0.8,
                fontSize,
                fontSize
              );
            }
          } else {
            ctx.fillText(part, currentX, currentY);
          }
          currentX += partWidth;
        }
        return currentY;
      }

      async function drawPlaneswalkerAbilities(
        ctx,
        text,
        startX,
        startY,
        maxWidth
      ) {
        if (!text) return startY;

        const abilities = text.split("\n").filter((ability) => ability.trim());
        let currentY = startY;
        const symbolSize = 32;
        const baseLineHeight = 9; // Ridotto drasticamente da 12 a 9
        const abilitySpacing = 4; // Ridotto da 8 a 4
        const maxY = CARD_HEIGHT - 50; // Limite per evitare strabordamento

        for (
          let abilityIndex = 0;
          abilityIndex < abilities.length && abilityIndex < 4; // Max 4 abilit√†
          abilityIndex++
        ) {
          const ability = abilities[abilityIndex];

          // Controlla se c'√® spazio per un'altra abilit√†
          if (currentY + symbolSize > maxY) {
            console.warn(
              "Spazio insufficiente per ulteriori abilit√† planeswalker"
            );
            break;
          }

          // Estrai il costo di lealt√† (es. "+1:", "-2:", "0:")
          const loyaltyMatch = ability.match(/^([+\-]?\d+):\s*(.+)$/);
          if (loyaltyMatch) {
            const cost = loyaltyMatch[1];
            const abilityText = loyaltyMatch[2];

            // Determina quale simbolo di lealt√† usare - con debug
            let symbolImg = null;
            if (cost.startsWith("+")) {
              symbolImg = assets.loyalty?.plus;
            } else if (cost.startsWith("-")) {
              symbolImg = assets.loyalty?.minus;
            } else if (cost === "0") {
              symbolImg = assets.loyalty?.zero;
            }

            // Debug per capire problemi con i simboli
            if (!symbolImg) {
              console.warn(`Simbolo lealt√† non trovato per costo: ${cost}`, {
                assetsLoyalty: assets.loyalty,
                symbolsAvailable: Object.keys(assets.loyalty || {}),
              });
            }

            // Posizioni fisse per layout
            const iconX = startX;
            const textX = startX + symbolSize + 8;
            const availableTextWidth = maxWidth - symbolSize - 8;

            // Setup del font - aumentato di 2px
            let fontSize = 12; // Aumentato da 10 a 12
            ctx.font = `${fontSize}px 'MPlantin'`;

            // Auto-ridimensionamento pi√π aggressivo
            const singleLineWidth = ctx.measureText(abilityText).width;
            if (singleLineWidth > availableTextWidth * 2) {
              fontSize = 11; // Aumentato da 9 a 11
              ctx.font = `${fontSize}px 'MPlantin'`;
            }
            if (singleLineWidth > availableTextWidth * 2.5) {
              fontSize = 10; // Aumentato da 8 a 10
              ctx.font = `${fontSize}px 'MPlantin'`;
            }

            // Wrapping del testo pi√π efficiente
            const words = abilityText.split(" ");
            const lines = [];
            let currentLine = "";

            for (const word of words) {
              const testLine = currentLine + (currentLine ? " " : "") + word;
              const testWidth = ctx.measureText(testLine).width;

              if (testWidth <= availableTextWidth || !currentLine) {
                currentLine = testLine;
              } else {
                lines.push(currentLine);
                currentLine = word;
              }
            }
            if (currentLine) lines.push(currentLine);

            // Limita il numero di righe per evitare overflow
            if (lines.length > 3) {
              console.warn(
                "Troppo testo per abilit√† planeswalker, troncando..."
              );
              lines.splice(3);
              if (lines[2] && lines[2].length > 30) {
                lines[2] = lines[2].substring(0, 27) + "...";
              }
            }

            // Calcola l'altezza totale necessaria per questa abilit√†
            const textHeight = lines.length * baseLineHeight;
            const abilityBlockHeight = Math.max(symbolSize + 2, textHeight + 4); // Ridotto padding

            // Posiziona il simbolo di lealt√† centrato verticalmente al blocco
            if (symbolImg?.complete) {
              const symbolY = currentY + (abilityBlockHeight - symbolSize) / 2;
              ctx.drawImage(symbolImg, iconX, symbolY, symbolSize, symbolSize);

              // Numero di lealt√† sul simbolo
              ctx.save();
              ctx.fillStyle = "white";
              ctx.font = "bold 11px 'Beleren Smallcaps'";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.strokeStyle = "black";
              ctx.lineWidth = 2;

              const numberX = iconX + symbolSize / 2;
              const numberY =
                symbolY + symbolSize / 2 + (cost.startsWith("-") ? -1 : 0);

              ctx.strokeText(cost, numberX, numberY);
              ctx.fillText(cost, numberX, numberY);
              ctx.restore();
            }

            // Disegna il testo con line-height ridotto
            ctx.fillStyle = "black";
            ctx.font = `${fontSize}px 'MPlantin'`;
            ctx.textAlign = "left";
            ctx.textBaseline = "alphabetic";

            const textStartY =
              currentY +
              (abilityBlockHeight - textHeight) / 2 +
              baseLineHeight * 0.7; // Ridotto da 0.8 a 0.7

            for (let i = 0; i < lines.length; i++) {
              const lineY = textStartY + i * baseLineHeight;
              // Verifica che non stiamo andando fuori dai bordi
              if (lineY > maxY - 10) break;
              ctx.fillText(lines[i], textX, lineY);
            }

            // Avanza currentY per la prossima abilit√†
            currentY += abilityBlockHeight + abilitySpacing;
          } else {
            // Gestione abilit√† malformata - formato pi√π compatto
            console.warn("Abilit√† planeswalker malformata:", ability);
            ctx.fillStyle = "black";
            ctx.font = "10px 'MPlantin'";
            ctx.fillText(ability, startX, currentY + 12);
            currentY += 16; // Ridotto da 20 a 16
          }
        }

        return currentY;
      }

      // --- UI & Event Handlers ---

      function downloadCard(canvas, cardName, cardRarity = null) {
        const link = document.createElement("a");
        const cleanName = cardName.replace(/[ /\\?%*:|"<>]/g, "_");
        const fileName = cardRarity
          ? `[${cardRarity.toUpperCase()}]_${cleanName}.png`
          : `${cleanName}.png`;
        link.download = fileName;
        link.href = canvas.toDataURL("image/png");
        link.click();
      }

      // Funzioni per il modale delle carte
      function openCardModal(cardData) {
        const modal = document.getElementById("card-modal");
        const modalCanvas = document.getElementById("modal-canvas");

        // Imposta dimensioni fisse per il canvas del modale (carta Magic standard)
        const cardWidth = 488;
        const cardHeight = 680;
        modalCanvas.width = cardWidth;
        modalCanvas.height = cardHeight;

        // Applica le dimensioni anche nel CSS per garantire il ridimensionamento corretto
        modalCanvas.style.width = cardWidth + "px";
        modalCanvas.style.height = cardHeight + "px";

        // Renderizza la carta nel modale a dimensione piena
        renderCardOnCanvas(cardData, modalCanvas);

        // Mostra il modale
        modal.classList.add("active");
        document.body.style.overflow = "hidden"; // Previene lo scroll del body
      }

      function closeCardModal() {
        const modal = document.getElementById("card-modal");
        modal.classList.remove("active");
        document.body.style.overflow = ""; // Ripristina lo scroll del body
      }

      // Chiudi il modale cliccando fuori
      document.getElementById("card-modal").addEventListener("click", (e) => {
        if (e.target.id === "card-modal") {
          closeCardModal();
        }
      });

      // Chiudi il modale con ESC
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          closeCardModal();
          closeBooster();
        }
      });

      // --- Booster Pack Functions ---

      function createBoosterPack() {
        if (generatedCards.length < 15) {
          alert("Hai bisogno di almeno 15 carte per creare un booster pack!");
          return null;
        }

        // Raggruppa le carte per rarit√† (case-insensitive)
        const cardsByRarity = {
          common: generatedCards.filter(
            (card) => card.rarity && card.rarity.toLowerCase() === "common"
          ),
          uncommon: generatedCards.filter(
            (card) => card.rarity && card.rarity.toLowerCase() === "uncommon"
          ),
          rare: generatedCards.filter(
            (card) => card.rarity && card.rarity.toLowerCase() === "rare"
          ),
          mythic: generatedCards.filter(
            (card) => card.rarity && card.rarity.toLowerCase() === "mythic"
          ),
        };

        console.log("Cards by rarity:", {
          common: cardsByRarity.common.length,
          uncommon: cardsByRarity.uncommon.length,
          rare: cardsByRarity.rare.length,
          mythic: cardsByRarity.mythic.length,
          totalGenerated: generatedCards.length,
        });

        const boosterCards = [];

        // Composizione tipica di un booster Magic:
        // 10-11 comuni, 3 non comuni, 1 rara/mythic, possibile foil

        // Aggiungi 10 comuni
        for (let i = 0; i < 10 && cardsByRarity.common.length > 0; i++) {
          const randomIndex = Math.floor(
            Math.random() * cardsByRarity.common.length
          );
          const card = cardsByRarity.common.splice(randomIndex, 1)[0];
          boosterCards.push({ ...card, boosterSlot: "common" });
        }

        // Aggiungi 3 non comuni
        for (let i = 0; i < 3 && cardsByRarity.uncommon.length > 0; i++) {
          const randomIndex = Math.floor(
            Math.random() * cardsByRarity.uncommon.length
          );
          const card = cardsByRarity.uncommon.splice(randomIndex, 1)[0];
          boosterCards.push({ ...card, boosterSlot: "uncommon" });
        }

        // Aggiungi 1 rara (10% di chance per mythic se disponibile)
        const availableRares = [...cardsByRarity.rare];
        if (cardsByRarity.mythic.length > 0 && Math.random() < 0.1) {
          const randomIndex = Math.floor(
            Math.random() * cardsByRarity.mythic.length
          );
          const card = cardsByRarity.mythic[randomIndex];
          boosterCards.push({ ...card, boosterSlot: "mythic" });
        } else if (availableRares.length > 0) {
          const randomIndex = Math.floor(Math.random() * availableRares.length);
          const card = availableRares[randomIndex];
          boosterCards.push({ ...card, boosterSlot: "rare" });
        }

        // Aggiungi una carta extra se abbiamo meno di 15, preservando la rarit√† originale
        while (
          boosterCards.length < 15 &&
          generatedCards.length > boosterCards.length
        ) {
          const allRemaining = generatedCards.filter(
            (card) =>
              !boosterCards.some(
                (boosterCard) => boosterCard.name === card.name
              )
          );
          if (allRemaining.length > 0) {
            const randomCard =
              allRemaining[Math.floor(Math.random() * allRemaining.length)];
            // Preserva la rarit√† originale invece di "extra"
            const originalRarity = randomCard.rarity
              ? randomCard.rarity.toLowerCase()
              : "common";
            boosterCards.push({ ...randomCard, boosterSlot: originalRarity });
          } else {
            break;
          }
        }

        console.log(
          "Booster cards before sorting:",
          boosterCards.map((card) => ({
            name: card.name,
            originalRarity: card.rarity,
            boosterSlot: card.boosterSlot,
          }))
        );

        // Ordina le carte dalla meno rara alla pi√π rara (comuni prime, mythic ultime)
        const rarityOrder = {
          common: 1,
          uncommon: 2,
          rare: 3,
          mythic: 4,
        };
        boosterCards.sort((a, b) => {
          const orderA = rarityOrder[a.boosterSlot] || 0;
          const orderB = rarityOrder[b.boosterSlot] || 0;
          return orderA - orderB;
        });

        console.log(
          "Booster cards after sorting:",
          boosterCards.map((card) => ({
            name: card.name,
            originalRarity: card.rarity,
            boosterSlot: card.boosterSlot,
            order: rarityOrder[card.boosterSlot],
          }))
        );

        return boosterCards;
      }

      function openBoosterInterface() {
        const boosterContainer = document.getElementById("booster-container");
        const packSelection = document.getElementById("pack-selection");
        const cardsRevealArea = document.getElementById("cards-reveal-area");

        // Reset state
        packSelection.style.display = "flex";
        cardsRevealArea.style.display = "none";
        cardsRevealArea.innerHTML = "";

        // Show booster container
        boosterContainer.style.display = "block";

        // Animate entrance
        gsap.fromTo(
          boosterContainer,
          { opacity: 0 },
          { opacity: 1, duration: 0.5 }
        );

        gsap.fromTo(
          ".booster-pack",
          { scale: 0, rotation: -10 },
          {
            scale: 1,
            rotation: 0,
            duration: 0.8,
            ease: "back.out(1.7)",
            delay: 0.3,
          }
        );
      }

      function openPack() {
        const boosterCards = createBoosterPack();
        if (!boosterCards) return;

        const packSelection = document.getElementById("pack-selection");
        const cardsRevealArea = document.getElementById("cards-reveal-area");
        const boosterTitle = document.querySelector(".booster-title");

        // Store cards for reveal process
        window.currentBoosterCards = boosterCards;
        window.currentCardIndex = 0;

        // Animate pack opening
        gsap.to(".booster-pack", {
          scale: 1.2,
          rotation: 5,
          duration: 0.2,
          yoyo: true,
          repeat: 3,
          onComplete: () => {
            gsap.to(".booster-pack", {
              scale: 0,
              rotation: 360,
              opacity: 0,
              duration: 0.8,
              ease: "power2.in",
              onComplete: () => {
                // Switch to cards reveal
                packSelection.style.display = "none";
                cardsRevealArea.style.display = "flex";
                cardsRevealArea.innerHTML = "";
                boosterTitle.textContent = `Clicca per rivelare la carta ${
                  window.currentCardIndex + 1
                }/15`;

                // Create click area for revealing cards
                createRevealInterface();
              },
            });
          },
        });
      }

      function createRevealInterface() {
        const cardsRevealArea = document.getElementById("cards-reveal-area");

        // Create click area
        const clickArea = document.createElement("div");
        clickArea.id = "reveal-click-area";
        clickArea.style.cssText = `
          width: 200px;
          height: 280px;
          background: linear-gradient(145deg, #3d4a87, #2e3a5f);
          border-radius: 15px;
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
          cursor: pointer;
          margin: 20px;
          display: flex;
          align-items: center;
          justify-content: center;
          border: 3px solid #ffd700;
          position: relative;
          transition: transform 0.3s ease, box-shadow 0.3s ease;
        `;

        const clickText = document.createElement("div");
        clickText.textContent = "Clicca per rivelare!";
        clickText.style.cssText = `
          color: #ffd700;
          font-family: 'Beleren Smallcaps', sans-serif;
          font-size: 18px;
          font-weight: bold;
          text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
          text-align: center;
          pointer-events: none;
        `;

        clickArea.appendChild(clickText);
        clickArea.addEventListener("click", revealNextCard);

        // Hover effects
        clickArea.addEventListener("mouseenter", () => {
          clickArea.style.transform = "scale(1.05)";
          clickArea.style.boxShadow = "0 15px 40px rgba(255, 215, 0, 0.3)";
        });

        clickArea.addEventListener("mouseleave", () => {
          clickArea.style.transform = "scale(1)";
          clickArea.style.boxShadow = "0 10px 30px rgba(0, 0, 0, 0.5)";
        });

        cardsRevealArea.appendChild(clickArea);
      }

      async function revealNextCard() {
        if (
          !window.currentBoosterCards ||
          window.currentCardIndex >= window.currentBoosterCards.length
        ) {
          return;
        }

        const cardsRevealArea = document.getElementById("cards-reveal-area");
        const boosterTitle = document.querySelector(".booster-title");
        const cardData = window.currentBoosterCards[window.currentCardIndex];

        // Remove click area
        const clickArea = document.getElementById("reveal-click-area");
        if (clickArea) {
          clickArea.remove();
        }

        // Create card element - centrata e a grandezza maggiore
        const cardContainer = document.createElement("div");
        cardContainer.className = "booster-card revealed";
        cardContainer.style.cssText = `
          display: flex;
          justify-content: center;
          align-items: center;
          width: 100%;
          height: auto;
          margin: 20px 0;
          transform: scale(0);
          opacity: 0;
          cursor: pointer;
        `;

        const canvas = document.createElement("canvas");
        canvas.width = CARD_WIDTH;
        canvas.height = CARD_HEIGHT;
        // Dimensioni pi√π grandi per il booster reveal
        canvas.style.width = "250px";
        canvas.style.height = "auto";
        canvas.style.borderRadius = "12px";
        canvas.style.boxShadow = "0 15px 40px rgba(0, 0, 0, 0.6)";
        canvas.style.transform = "rotate(0deg)"; // Assicura che sia dritta

        // Clear previous cards (mostra solo una carta alla volta)
        cardsRevealArea.innerHTML = "";

        // Render the card
        await renderCardOnCanvas(cardData, canvas);

        // Add click handler to view full size
        canvas.addEventListener("click", () => {
          openCardModal(cardData);
        });

        cardContainer.appendChild(canvas);
        cardsRevealArea.appendChild(cardContainer);

        // Animate card reveal - scala da 0 a 1, dritta
        gsap.to(cardContainer, {
          scale: 1,
          opacity: 1,
          duration: 0.8,
          ease: "back.out(1.7)",
        });

        // Add rarity sparkle effect for rare cards
        if (cardData.rarity === "rare" || cardData.rarity === "mythic") {
          setTimeout(() => {
            addSparkleEffect(cardContainer);
          }, 600);
        }

        window.currentCardIndex++;

        // Update title and create next click area
        if (window.currentCardIndex < window.currentBoosterCards.length) {
          const nextCard = window.currentBoosterCards[window.currentCardIndex];
          const rarityText =
            nextCard.boosterSlot === "mythic"
              ? "MYTHIC"
              : nextCard.boosterSlot === "rare"
              ? "RARA"
              : nextCard.boosterSlot === "uncommon"
              ? "NON COMUNE"
              : "COMUNE";

          boosterTitle.textContent = `Prossima carta: ${rarityText} (${
            window.currentCardIndex + 1
          }/15)`;

          // Create continue button dopo un breve delay
          setTimeout(() => {
            const continueBtn = document.createElement("button");
            continueBtn.id = "reveal-click-area";
            continueBtn.textContent = "Rivela Prossima Carta";
            continueBtn.style.cssText = `
              background: linear-gradient(145deg, #3d4a87, #2e3a5f);
              color: #ffd700;
              border: 2px solid #ffd700;
              border-radius: 10px;
              padding: 15px 30px;
              font-family: 'Beleren Smallcaps', sans-serif;
              font-size: 16px;
              font-weight: bold;
              cursor: pointer;
              margin-top: 20px;
              transition: all 0.3s ease;
              text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
              box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            `;

            continueBtn.addEventListener("click", revealNextCard);
            continueBtn.addEventListener("mouseenter", () => {
              continueBtn.style.transform = "scale(1.05)";
              continueBtn.style.boxShadow =
                "0 12px 35px rgba(255, 215, 0, 0.3)";
            });
            continueBtn.addEventListener("mouseleave", () => {
              continueBtn.style.transform = "scale(1)";
              continueBtn.style.boxShadow = "0 8px 25px rgba(0, 0, 0, 0.4)";
            });

            cardsRevealArea.appendChild(continueBtn);
          }, 1000);
        } else {
          boosterTitle.textContent = "Booster Pack completato! üéâ";

          // Mostra pulsante per rivedere tutte le carte
          setTimeout(() => {
            const reviewBtn = document.createElement("button");
            reviewBtn.textContent = "Rivedi Tutte le Carte";
            reviewBtn.style.cssText = `
              background: linear-gradient(145deg, #4a6741, #2e4a25);
              color: #ffd700;
              border: 2px solid #ffd700;
              border-radius: 10px;
              padding: 15px 30px;
              font-family: 'Beleren Smallcaps', sans-serif;
              font-size: 16px;
              font-weight: bold;
              cursor: pointer;
              margin-top: 20px;
              transition: all 0.3s ease;
            `;

            reviewBtn.addEventListener("click", () => {
              showAllBoosterCards();
            });

            cardsRevealArea.appendChild(reviewBtn);
          }, 1000);
        }
      }

      async function revealCards(boosterCards) {
        const cardsRevealArea = document.getElementById("cards-reveal-area");

        // Create all card elements first (hidden)
        const cardElements = await Promise.all(
          boosterCards.map(async (cardData, index) => {
            const cardContainer = document.createElement("div");
            cardContainer.className = "booster-card";

            const canvas = document.createElement("canvas");
            canvas.width = CARD_WIDTH;
            canvas.height = CARD_HEIGHT;
            canvas.style.width = "120px";
            canvas.style.height = "auto";

            // Render the card
            await renderCardOnCanvas(cardData, canvas);

            // Add click handler to view full size
            canvas.addEventListener("click", () => {
              openCardModal(cardData);
            });

            cardContainer.appendChild(canvas);
            cardsRevealArea.appendChild(cardContainer);

            return cardContainer;
          })
        );

        // Animate cards appearing one by one
        cardElements.forEach((cardElement, index) => {
          gsap.to(cardElement, {
            rotationY: 0,
            scale: 1,
            opacity: 1,
            duration: 0.6,
            delay: index * 0.15, // Stagger animation
            ease: "back.out(1.7)",
            onStart: () => {
              cardElement.classList.add("revealed");
            },
          });

          // Add rarity sparkle effect for rare cards
          const cardData = boosterCards[index];
          if (cardData.rarity === "rare" || cardData.rarity === "mythic") {
            setTimeout(() => {
              addSparkleEffect(cardElement);
            }, index * 150 + 600);
          }
        });
      }

      function addSparkleEffect(cardElement) {
        // Create sparkle particles around rare/mythic cards
        for (let i = 0; i < 8; i++) {
          const sparkle = document.createElement("div");
          sparkle.style.cssText = `
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #ffd700, #ffed4e);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
          `;

          const rect = cardElement.getBoundingClientRect();
          sparkle.style.left = rect.left + rect.width / 2 + "px";
          sparkle.style.top = rect.top + rect.height / 2 + "px";

          document.body.appendChild(sparkle);

          // Animate sparkle
          gsap.to(sparkle, {
            x: (Math.random() - 0.5) * 200,
            y: (Math.random() - 0.5) * 200,
            opacity: 0,
            scale: 0,
            duration: 1.5,
            ease: "power2.out",
            onComplete: () => {
              document.body.removeChild(sparkle);
            },
          });
        }
      }

      function closeBooster() {
        const boosterContainer = document.getElementById("booster-container");

        // Reset booster state
        window.currentBoosterCards = null;
        window.currentCardIndex = 0;

        // Reset UI
        const packSelection = document.getElementById("pack-selection");
        const cardsRevealArea = document.getElementById("cards-reveal-area");
        const boosterTitle = document.querySelector(".booster-title");

        packSelection.style.display = "flex";
        cardsRevealArea.style.display = "none";
        cardsRevealArea.innerHTML = "";
        boosterTitle.textContent = "Apri il tuo Booster Pack!";

        gsap.to(boosterContainer, {
          opacity: 0,
          duration: 0.3,
          onComplete: () => {
            boosterContainer.style.display = "none";
          },
        });
      }

      const showLoading = (
        isLoading,
        message = "L'AI sta forgiando le carte..."
      ) => {
        loadingIndicator.classList.toggle("hidden", !isLoading);
        generationStatus.textContent = message;
        generateBtn.disabled = isLoading;
        stopBtn.classList.toggle("hidden", !isLoading);
        generateBtn.textContent = isLoading ? "Generazione..." : "Genera Carte";
        generateBtn.classList.toggle("opacity-50", isLoading);
        generateBtn.classList.toggle("cursor-not-allowed", isLoading);
        if (!isLoading) {
          timeEstimation.textContent = "";
          loadingIndicator.classList.remove("desktop-sticky");
        }
      };

      const showError = (message) => {
        errorMessage.textContent = message;
        errorMessage.classList.remove("hidden");
      };

      function createInlineEditForm(cardData, wrapper, cardIndex) {
        const form = document.createElement("div");
        form.className = "edit-form space-y-2";
        form.innerHTML = `
            <div><label>Nome:</label><input type="text" value="${
              cardData.name || ""
            }"></div>
            <div><label>Costo:</label><input type="text" value="${
              cardData.manaCost || ""
            }"></div>
            <div><label>Tipo:</label><input type="text" value="${
              cardData.type || ""
            }"></div>
            <div><label>Testo:</label><textarea rows="3">${
              cardData.text || ""
            }</textarea></div>
            <div class="grid grid-cols-2 gap-2">
                <div><label>Forza:</label><input type="text" value="${
                  cardData.power || ""
                }"></div>
                <div><label>Cost.:</label><input type="text" value="${
                  cardData.toughness || ""
                }"></div>
            </div>
            <div class="flex justify-end gap-2 pt-2">
                <button class="cancel-edit-btn bg-gray-600 hover:bg-gray-700 py-1 px-3 rounded text-sm">Annulla</button>
                <button class="save-edit-btn bg-green-600 hover:bg-green-700 py-1 px-3 rounded text-sm">Salva</button>
            </div>
        `;

        const canvas = wrapper.querySelector("canvas");

        form.querySelector(".save-edit-btn").addEventListener("click", () => {
          const inputs = form.querySelectorAll("input, textarea");
          const updatedCardData = generatedCards[cardIndex];

          updatedCardData.name = inputs[0].value;
          updatedCardData.manaCost = inputs[1].value;
          updatedCardData.type = inputs[2].value;
          updatedCardData.text = inputs[3].value;
          updatedCardData.power = inputs[4].value;
          updatedCardData.toughness = inputs[5].value;

          // Forza il ricalcolo del colorIdentity quando viene modificato il manaCost
          updatedCardData.colorIdentity = "DA_DETERMINARE_DA_MANA_COST";

          renderCardOnCanvas(updatedCardData, canvas);
          form.remove();
          canvas.style.display = "block";
        });

        form.querySelector(".cancel-edit-btn").addEventListener("click", () => {
          form.remove();
          canvas.style.display = "block";
        });

        return form;
      }

      async function regenerateArt(wrapper, cardIndex) {
        const cardData = generatedCards[cardIndex];
        const canvas = wrapper.querySelector("canvas");

        const loader = document.createElement("div");
        loader.className = "card-loader";
        loader.innerHTML =
          '<svg class="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path></svg>';
        wrapper.prepend(loader);

        try {
          const artPrompt = `Magic: The Gathering card art, epic, high fantasy digital painting. Subject: ${cardData.artDescription}`;
          const imagePayload = {
            instances: [{ prompt: artPrompt }],
            parameters: { sampleCount: 1 },
          };
          const imageResult = await robustFetch(
            `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict`,
            imagePayload
          );
          if (imageResult.predictions?.[0]?.bytesBase64Encoded) {
            cardData.artImage = await loadImage(
              `data:image/png;base64,${imageResult.predictions[0].bytesBase64Encoded}`
            );
          }
          await renderCardOnCanvas(cardData, canvas);
        } catch (error) {
          console.error("Errore rigenerazione arte:", error);
          showError(`Errore rigenerazione arte per ${cardData.name}.`);
        } finally {
          loader.remove();
        }
      }

      // --- Main Generation Logic ---

      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

      function createSetBlueprint(
        totalCount,
        selectedColors = [],
        mode = "single",
        setMechanic = null
      ) {
        const blueprint = Array.from({ length: totalCount }, () => ({}));

        // Per modalit√† singola, rispetta esattamente i colori selezionati
        if (mode === "single") {
          for (let i = 0; i < totalCount; i++) {
            blueprint[i] = {
              type: "Carta Libera", // Lascia che l'AI decida basandosi sul prompt
              rarity: "Rare", // Default per carte singole
              colorIdentity:
                selectedColors.length > 1
                  ? "Gold"
                  : selectedColors.length === 1
                  ? selectedColors[0]
                  : null, // null indica che l'AI deve decidere
              specificColors: selectedColors, // Passa i colori specifici
              setMechanic: null, // Carte singole non usano meccaniche del set
            };
          }
          return blueprint;
        }

        // Modalit√† Commander: la prima carta deve essere il commander
        if (mode === "commander" && totalCount > 0) {
          blueprint[0] = {
            type: "Creatura Leggendaria",
            rarity: "Mythic", // I commander sono tipicamente mythic
            colorIdentity:
              selectedColors.length > 1 ? "Gold" : selectedColors[0] || "White",
            specificColors: selectedColors, // Passa TUTTI i colori selezionati
            isCommander: true,
          };
        }

        // 1. Assign Rarities (per le carte rimanenti)
        const rarities = [];
        const startIndex = mode === "commander" ? 1 : 0;
        const remainingCount = totalCount - startIndex;

        const mythicCount = Math.round(remainingCount * 0.075);
        const rareCount = Math.round(remainingCount * 0.225);
        const uncommonCount = Math.round(remainingCount * 0.38);
        const commonCount =
          remainingCount - mythicCount - rareCount - uncommonCount;

        for (let i = 0; i < mythicCount; i++) rarities.push("Mythic");
        for (let i = 0; i < rareCount; i++) rarities.push("Rare");
        for (let i = 0; i < uncommonCount; i++) rarities.push("Uncommon");
        for (let i = 0; i < commonCount; i++) rarities.push("Common");
        shuffleArray(rarities);

        for (let i = startIndex; i < totalCount; i++) {
          if (!blueprint[i].rarity) {
            blueprint[i].rarity = rarities[i - startIndex] || "Common";
          }
        }

        // 2. Assign Types (per le carte rimanenti)
        const types = [];
        const remainingForTypes = totalCount - startIndex;

        const creatureCount = Math.round(remainingForTypes * 0.48);
        const spellCount = Math.round(remainingForTypes * 0.25);
        const permanentCount = Math.round(remainingForTypes * 0.12);
        const planeswalkerCount = Math.round(remainingForTypes * 0.1); // Aumentato per migliorare le chance
        const landCount =
          remainingForTypes -
          creatureCount -
          spellCount -
          permanentCount -
          planeswalkerCount;

        for (let i = 0; i < creatureCount; i++) types.push("Creatura");
        for (let i = 0; i < spellCount; i++)
          types.push("Istantaneo o Stregoneria");
        for (let i = 0; i < permanentCount; i++)
          types.push("Incantesimo o Artefatto");
        for (let i = 0; i < planeswalkerCount; i++)
          types.push("Planeswalker - Specifico"); // Pi√π specifico
        for (let i = 0; i < landCount; i++) types.push("Terra non base");

        shuffleArray(types);

        // Assegna i tipi alle carte rimanenti
        for (let i = startIndex; i < totalCount; i++) {
          if (!blueprint[i].type) {
            blueprint[i].type = types[i - startIndex] || "Creatura";
          }
        }

        // 3. Assign Colors (considera colori selezionati)
        const colors = [];
        const nonLandCards = blueprint.filter(
          (card) => card.type !== "Terra non base"
        );
        const nonLandCount = nonLandCards.length;

        // Usa i colori selezionati o tutti i colori se nessuno √® selezionato
        const availableColors =
          selectedColors.length > 0
            ? selectedColors.filter((color) => color !== "Colorless")
            : ["White", "Blue", "Black", "Red", "Green"];

        const includeColorless =
          selectedColors.length === 0 || selectedColors.includes("Colorless");

        const multicolorCount =
          availableColors.length > 1 ? Math.round(nonLandCount * 0.13) : 0;
        const colorlessCount = includeColorless
          ? Math.round(nonLandCount * 0.08)
          : 0;
        const monocolorTotal = nonLandCount - multicolorCount - colorlessCount;
        const perColorCount =
          availableColors.length > 0
            ? Math.floor(monocolorTotal / availableColors.length)
            : 0;

        for (let i = 0; i < multicolorCount; i++) colors.push("Gold");
        for (let i = 0; i < colorlessCount; i++) colors.push("Artifact");

        availableColors.forEach((color) => {
          for (let i = 0; i < perColorCount; i++) colors.push(color);
        });

        // Distribute remaining monocolor cards
        const remainder = monocolorTotal % (availableColors.length || 1);
        shuffleArray(availableColors);
        for (let i = 0; i < remainder && i < availableColors.length; i++) {
          colors.push(availableColors[i]);
        }

        shuffleArray(colors);

        let colorIndex = 0;
        blueprint.forEach((card) => {
          if (card.type === "Terra non base") {
            card.colorIdentity = "Land";
          } else if (colorIndex < colors.length) {
            card.colorIdentity = colors[colorIndex++];
          } else {
            // Fallback
            card.colorIdentity =
              availableColors.length > 0 ? availableColors[0] : "Artifact";
          }
        });

        // Post-processing: applica regole per i planeswalker nel blueprint
        blueprint.forEach((card, index) => {
          const isPlaneswalkerBlueprint =
            card.type &&
            (card.type.includes("Planeswalker") ||
              card.type === "Planeswalker - Specifico");

          if (isPlaneswalkerBlueprint) {
            console.log(
              `Applying planeswalker blueprint rules for card ${index}:`,
              {
                type: card.type,
                originalRarity: card.rarity,
              }
            );

            // REGOLA 1: I planeswalker NON possono MAI essere Common nel blueprint
            if (card.rarity && card.rarity.toLowerCase() === "common") {
              // Upgrade automatico con distribuzione pesata verso Rare/Mythic
              const upgradeRoll = Math.random();
              if (upgradeRoll < 0.15) {
                // 15% chance
                card.rarity = "Uncommon";
              } else if (upgradeRoll < 0.75) {
                // 60% chance (15-75%)
                card.rarity = "Rare";
              } else {
                // 25% chance (75-100%)
                card.rarity = "Mythic";
              }
              console.log(
                `Blueprint: Planeswalker ${index} upgraded from Common to ${card.rarity}`
              );
            }

            // REGOLA 2: Bias verso Rare/Mythic anche per altri planeswalker
            if (card.rarity && card.rarity.toLowerCase() === "rare") {
              // 30% chance di upgrade da Rare a Mythic
              if (Math.random() < 0.3) {
                card.rarity = "Mythic";
                console.log(
                  `Blueprint: Planeswalker ${index} upgraded from Rare to Mythic (bias)`
                );
              }
            }

            console.log(`Final planeswalker blueprint for card ${index}:`, {
              type: card.type,
              finalRarity: card.rarity,
              colorIdentity: card.colorIdentity,
            });
          }
        });

        // 4. Distribuisci la meccanica del set (se presente) al ~30% delle carte
        if (setMechanic) {
          const mechanicTargetCount = Math.floor(totalCount * 0.3);
          const mechanicIndices = [];

          // Seleziona casualmente le carte che avranno la meccanica
          while (mechanicIndices.length < mechanicTargetCount) {
            const randomIndex = Math.floor(Math.random() * totalCount);
            if (!mechanicIndices.includes(randomIndex)) {
              mechanicIndices.push(randomIndex);
            }
          }

          mechanicIndices.forEach((index) => {
            blueprint[index].setMechanic = setMechanic;
          });

          console.log(
            `Set mechanic "${setMechanic.name}" distributed to ${mechanicTargetCount} cards out of ${totalCount}:`,
            mechanicIndices
          );
        }

        return blueprint;
      }

      async function robustFetch(url, payload, retries = 3) {
        for (let i = 0; i < retries; i++) {
          if (isGenerationStopped)
            throw new Error("Generazione interrotta dall'utente.");
          try {
            const response = await fetch(`${url}?key=${apiKey}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            if (response.ok) return await response.json();
            if (response.status === 429 || response.status === 401) {
              console.warn(
                `Rate limit/Auth error (${response.status}). Tentativo ${
                  i + 1
                }. Attendo...`
              );
              await new Promise((res) => setTimeout(res, 2000 * (i + 1)));
            } else {
              const errorBody = await response.text();
              throw new Error(
                `API Error: ${response.status}. Body: ${errorBody}`
              );
            }
          } catch (error) {
            console.error(`Fetch fallito (tentativo ${i + 1}):`, error);
            if (i === retries - 1) throw error;
          }
        }
      }

      async function generateCardText(theme, cardBlueprint, history) {
        const historyPrompt =
          history.length > 0
            ? `Finora, hai creato le seguenti carte in questo set: ${history}. Basandoti su queste, crea la nuova carta.`
            : `Questa √® l'inizio di un nuovo set. Crea la prima carta.`;

        // Determina il tipo di carta e i colori specifici
        const isPlaneswalker =
          cardBlueprint.type &&
          (cardBlueprint.type.includes("Planeswalker") ||
            cardBlueprint.type === "Planeswalker - Specifico" ||
            cardBlueprint.type === "Carta Libera"); // Per carte singole, controlla il tema
        const isCommander = cardBlueprint.isCommander;
        const isFreeForm = cardBlueprint.type === "Carta Libera";

        // Prepara i colori specifici per il prompt
        const specificColors = cardBlueprint.specificColors || [];

        // FORZA il frame_style per i planeswalker gi√† nel blueprint
        if (isPlaneswalker && cardBlueprint.type.includes("Planeswalker")) {
          cardBlueprint.frame_style = "Planeswalker";
          console.log(
            "Forcing Planeswalker frame_style in blueprint for:",
            cardBlueprint.type
          );
        }
        const colorDescription =
          specificColors.length > 0
            ? `ESATTAMENTE questi colori: ${specificColors.join(" e ")}`
            : cardBlueprint.colorIdentity === null
            ? "i colori che meglio si adattano al tema (decidi tu)"
            : cardBlueprint.colorIdentity;

        // Determinazione automatica del colorIdentity se non specificato
        const autoColorIdentity =
          cardBlueprint.colorIdentity || "DA_DETERMINARE_DA_MANA_COST";

        // Prepara informazioni sulla meccanica del set (se presente)
        const setMechanicPrompt = cardBlueprint.setMechanic
          ? `
MECCANICA DEL SET:
Questa carta DEVE utilizzare la meccanica del set "${cardBlueprint.setMechanic.name}".
Descrizione: ${cardBlueprint.setMechanic.description}
Keyword: ${cardBlueprint.setMechanic.keywordDescription}
Integra questa meccanica nel testo della carta in modo naturale e tematico.
`
          : "";

        let instructionPrompt;

        if (isFreeForm) {
          // Per carte singole, lascia l'AI decidere il tipo ma forza i colori
          const planeswalkerHint = theme.toLowerCase().includes("planeswalker")
            ? "Se il tema suggerisce un planeswalker, crea un planeswalker con il formato strutturato delle abilit√†. "
            : "";

          const planeswalkerFormatHint = theme
            .toLowerCase()
            .includes("planeswalker")
            ? `
            
SE CREI UN PLANESWALKER, usa il formato strutturato OBBLIGATORIO:
- NON includere il campo "text"
- USA il campo "abilities" come array di oggetti: [{"cost": "+1", "description": "Testo abilit√†"}, ...]
- Ogni abilit√† deve essere un oggetto separato con "cost" (es: "+1", "-2", "0") e "description"
- Imposta "frame_style" a "Planeswalker"
- Se la rarit√† √® "Uncommon": massimo 2 abilit√†, nessuna ultimate (costo -6 o superiore)
- Se la rarit√† √® "Rare" o "Mythic": puoi avere 2-4 abilit√† inclusa una ultimate
            `
            : "";

          // 10% di possibilit√† per borderless anche nelle carte singole (non planeswalker)
          const frameStyleForSingle = theme
            .toLowerCase()
            .includes("planeswalker")
            ? "Planeswalker"
            : Math.random() < 0.1
            ? "Borderless"
            : "Standard Colors";

          instructionPrompt = `Crea una carta di Magic: The Gathering basata ESATTAMENTE su questo tema: "${theme}". ${planeswalkerHint}La carta DEVE utilizzare ${colorDescription}. Se sono specificati pi√π colori, la carta DEVE essere multicolore e includere TUTTI i colori nel costo di mana. ${historyPrompt} TUTTO il testo della carta DEVE essere in italiano. Il formato del costo di mana deve essere corretto (es. {2}{W}{U}).${setMechanicPrompt}${planeswalkerFormatHint} Fornisci un oggetto JSON con: name, manaCost (DEVE includere tutti i colori specificati), type (in italiano, es. 'Planeswalker - Nome' se √® un planeswalker, 'Creatura - Tipo' se √® una creatura, etc.), text (in italiano, solo per NON-planeswalker), abilities (array strutturato, solo per planeswalker), power (per creature), toughness (per creature), startingLoyalty (per planeswalker), artDescription. IMPORTANTE: L'oggetto JSON deve avere "colorIdentity" basato sui colori del manaCost (W per bianco, U per blu, B per nero, R per rosso, G per verde, Gold per multicolore, Artifact se nessun colore), "rarity" impostato a "${cardBlueprint.rarity}" e "frame_style" a "${frameStyleForSingle}". Rispondi solo con un oggetto JSON valido.`;
        } else if (isPlaneswalker) {
          // Aggiungi regole specifiche per la rarit√† del planeswalker
          const rarityRules =
            cardBlueprint.rarity &&
            cardBlueprint.rarity.toLowerCase() === "uncommon"
              ? `
REGOLE SPECIALI PER PLANESWALKER UNCOMMON:
- Massimo 2 abilit√† (non di pi√π)
- NON includere abilit√† ultimate (con costo -6 o superiore)
- Le abilit√† devono essere semplici e bilanciate per la rarit√† Uncommon`
              : `
REGOLE PER PLANESWALKER RARE/MYTHIC:
- Puoi avere 2-4 abilit√†
- Includi un'abilit√† ultimate potente (tipicamente -6 o -7)
- Le abilit√† devono essere proporzionate alla rarit√†`;

          instructionPrompt = `Crea un Planeswalker di Magic: The Gathering per un set a tema "${theme}". Il planeswalker DEVE utilizzare ${colorDescription}. Se sono specificati pi√π colori, DEVE essere multicolore e includere TUTTI i colori nel costo di mana. ${historyPrompt} TUTTO il testo della carta DEVE essere in italiano. ${setMechanicPrompt}

FORMATO STRUTTURATO OBBLIGATORIO - Invece del campo "text", usa il campo "abilities" che deve essere un array di oggetti con questa struttura ESATTA:

{
  "name": "Nome del Planeswalker",
  "manaCost": "${
    cardBlueprint.colorIdentity === "Gold"
      ? "{3}{W}{U}"
      : `{3}{${cardBlueprint.colorIdentity.charAt(0).toUpperCase()}}`
  }",
  "type": "Planeswalker - Nome",
  "abilities": [
    {"cost": "+1", "description": "Pesca una carta e guadagni 1 punto vita."},
    {"cost": "-2", "description": "Distruggi una creatura bersaglio non artefatto."},
    {"cost": "-6", "description": "Ottieni un emblema con \\"Le creature che controlli hanno doppio attacco\\""}
  ],
  "startingLoyalty": 4,
  "artDescription": "...",
  "colorIdentity": "${cardBlueprint.colorIdentity}",
  "rarity": "${cardBlueprint.rarity}",
  "frame_style": "Planeswalker"
}
${rarityRules}

REGOLE RIGOROSE:
- OGNI abilit√† deve essere un oggetto separato nell'array "abilities"
- Il campo "cost" deve contenere SOLO il costo (es: "+1", "-2", "0", "-6")
- Il campo "description" deve contenere SOLO il testo dell'abilit√† senza il costo
- NON includere il campo "text"
- Il formato deve essere ESATTO o la carta non funzioner√†
- frame_style DEVE SEMPRE essere "Planeswalker"

Fornisci un oggetto JSON con: name, manaCost (DEVE includere tutti i colori specificati), type (in italiano, es. 'Planeswalker - Jace'), abilities (array strutturato come sopra), startingLoyalty (numero tra 2 e 6), artDescription. IMPORTANTE: L'oggetto JSON deve avere "colorIdentity" basato sui colori del manaCost, "rarity" impostato a "${
            cardBlueprint.rarity
          }" e "frame_style" a "Planeswalker". Rispondi solo con un oggetto JSON valido.`;
        } else if (isCommander) {
          const colorList =
            specificColors.length > 0
              ? specificColors.join(", ")
              : cardBlueprint.colorIdentity;
          instructionPrompt = `Crea un Commander (Creatura Leggendaria) di Magic: The Gathering per un mazzo Commander a tema "${theme}". Il commander DEVE utilizzare ESATTAMENTE questi colori: ${colorList}. Il costo di mana DEVE includere TUTTI questi colori: ${specificColors
            .map((c) => `{${c.charAt(0).toUpperCase()}}`)
            .join(
              ""
            )}. ${historyPrompt} TUTTO il testo della carta DEVE essere in italiano. I commander sono creature leggendarie potenti che definiscono l'identit√† del mazzo. Fornisci un oggetto JSON con: name, manaCost (DEVE includere tutti i colori: ${specificColors
            .map((c) => c.charAt(0).toUpperCase())
            .join(
              ", "
            )}), type (in italiano, es. 'Creatura Leggendaria - Drago Guerriero'), text (abilit√† potenti adatte a un commander), power, toughness, artDescription. L'oggetto JSON DEVE avere "colorIdentity", "rarity" e "frame_style" impostati a "${
            cardBlueprint.colorIdentity
          }", "${
            cardBlueprint.rarity
          }" e "Standard Colors". Rispondi solo con un oggetto JSON valido.`;
          const allSelectedColors =
            cardBlueprint.colorIdentity === "Gold"
              ? "multicolore"
              : cardBlueprint.colorIdentity;
          instructionPrompt = `Crea un Commander (Creatura Leggendaria) di Magic: The Gathering per un mazzo Commander a tema "${theme}". Il commander DEVE essere: Tipo: Creatura Leggendaria, Rarit√†: Mythic, Colori: ${allSelectedColors}. ${historyPrompt} TUTTO il testo della carta DEVE essere in italiano. I commander sono creature leggendarie potenti che definiscono l'identit√† del mazzo. ${setMechanicPrompt}Fornisci un oggetto JSON con: name, manaCost (deve includere TUTTI i colori selezionati), type (in italiano, es. 'Creatura Leggendaria - Drago Guerriero'), text (abilit√† potenti adatte a un commander), power, toughness, artDescription. L'oggetto JSON DEVE avere "colorIdentity", "rarity" e "frame_style" impostati a "${cardBlueprint.colorIdentity}", "${cardBlueprint.rarity}" e "Standard Colors". Rispondi solo con un oggetto JSON valido.`;
        } else {
          // 10% di possibilit√† per carte borderless (eccetto planeswalker e commander)
          const frameStyle =
            Math.random() < 0.1 ? "Borderless" : "Standard Colors";

          instructionPrompt = `Crea una carta di Magic: The Gathering per un set a tema "${theme}". La carta DEVE rispettare queste specifiche: Tipo: ${
            cardBlueprint.type
          }, Rarit√†: ${cardBlueprint.rarity}, Colore: ${
            cardBlueprint.colorIdentity
          }. ${historyPrompt} TUTTO il testo della carta, inclusi i nomi delle abilit√†, DEVE essere in italiano. Utilizza le abilit√† ufficiali italiane quando possibili, come: ${ITALIAN_KEYWORDS.join(
            ", "
          )}. La carta deve essere bilanciata. Il formato del costo di mana deve essere corretto (es. {2}{W}{U}). ${setMechanicPrompt}Fornisci un oggetto JSON con: name, manaCost, type (in italiano, specifico, es. 'Creatura - Guerriero Umano'), text (in italiano, con simboli mana), power (per creature), toughness (per creature), artDescription (descrizione vivida per AI). L'oggetto JSON DEVE avere i campi "colorIdentity", "rarity" e "frame_style" impostati rispettivamente a "${
            cardBlueprint.colorIdentity
          }", "${
            cardBlueprint.rarity
          }" e "${frameStyle}". NON includere 'flavorText'. Rispondi solo con un oggetto JSON valido.`;
        }

        // Schema dinamico basato sul tipo di carta
        const baseSchema = {
          name: { type: "STRING" },
          manaCost: { type: "STRING" },
          colorIdentity: { type: "STRING" },
          rarity: { type: "STRING" },
          type: { type: "STRING" },
          frame_style: { type: "STRING" },
          artDescription: { type: "STRING" },
        };

        const schemaProperties = { ...baseSchema };
        const requiredFields = [
          "name",
          "manaCost",
          "colorIdentity",
          "rarity",
          "type",
          "frame_style",
          "artDescription",
        ];

        // Aggiungi campi specifici per planeswalker
        if (isPlaneswalker || isFreeForm) {
          schemaProperties.startingLoyalty = { type: "INTEGER" };
          // Per i planeswalker usa il campo abilities strutturato invece di text
          schemaProperties.abilities = {
            type: "ARRAY",
            items: {
              type: "OBJECT",
              properties: {
                cost: { type: "STRING" },
                description: { type: "STRING" },
              },
              required: ["cost", "description"],
            },
          };
          requiredFields.push("startingLoyalty", "abilities");
        } else {
          // Per le altre carte usa il campo text normale
          schemaProperties.text = { type: "STRING" };
          requiredFields.push("text");
        }

        // Aggiungi campi per creature (inclusi commander e forme libere)
        if (!isPlaneswalker || isFreeForm) {
          schemaProperties.power = { type: "STRING" };
          schemaProperties.toughness = { type: "STRING" };
        }

        const textGenPayload = {
          contents: [{ role: "user", parts: [{ text: instructionPrompt }] }],
          generationConfig: {
            responseMimeType: "application/json",
            responseSchema: {
              type: "OBJECT",
              properties: schemaProperties,
              required: requiredFields,
            },
          },
        };
        const textResult = await robustFetch(
          `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent`,
          textGenPayload
        );
        return JSON.parse(textResult.candidates[0].content.parts[0].text);
      }

      // Mostra la meccanica del set generata nell'interfaccia
      function displaySetMechanic(setMechanic) {
        if (!setMechanic) return;

        const mechanicDisplay = document.getElementById("set-mechanic-display");
        const mechanicName = document.getElementById("mechanic-name");
        const mechanicDescription = document.getElementById(
          "mechanic-description"
        );
        const mechanicFlavor = document.getElementById("mechanic-flavor");

        mechanicName.textContent = setMechanic.name;
        mechanicDescription.textContent = setMechanic.keywordDescription;
        mechanicFlavor.textContent = setMechanic.flavorDescription;

        mechanicDisplay.classList.remove("hidden");
        console.log("Set mechanic displayed in UI:", setMechanic.name);
      }

      // Nasconde la meccanica del set dall'interfaccia
      function hideSetMechanic() {
        const mechanicDisplay = document.getElementById("set-mechanic-display");
        mechanicDisplay.classList.add("hidden");
      }

      // Genera una meccanica personalizzata per il set
      async function generateSetMechanic(theme, selectedColors) {
        console.log("Generating set mechanic for theme:", theme);

        const colorDescription =
          selectedColors.length > 0
            ? `usando principalmente i colori ${selectedColors.join(" e ")}`
            : "utilizzando tutti i colori";

        const instructionPrompt = `Crea una nuova meccanica per un set di Magic: The Gathering a tema "${theme}" ${colorDescription}. 

La meccanica deve essere:
- Unica e tematica al set
- Bilanciata e interessante dal punto di vista del gameplay
- Applicabile a diversi tipi di carte (creature, istantanei, stregonerie, incantesimi)
- Con un nome evocativo che riflette il tema
- Non essere una meccanica gi√† esistente di Magic

FORMATO RICHIESTO - Rispondi con un oggetto JSON che contiene:
{
  "name": "Nome della meccanica (in italiano)",
  "description": "Descrizione completa della meccanica con le regole",
  "keywordDescription": "Descrizione breve per il testo delle carte",
  "flavorDescription": "Descrizione del flavor e del perch√© si adatta al tema",
  "examples": ["Esempio 1", "Esempio 2", "Esempio 3"]
}

La meccanica deve essere in italiano e adatta al tema "${theme}". Sii creativo ma mantieni la meccanica bilanciata.`;

        try {
          const mechanicPayload = {
            contents: [{ role: "user", parts: [{ text: instructionPrompt }] }],
            generationConfig: {
              responseMimeType: "application/json",
              responseSchema: {
                type: "OBJECT",
                properties: {
                  name: { type: "STRING" },
                  description: { type: "STRING" },
                  keywordDescription: { type: "STRING" },
                  flavorDescription: { type: "STRING" },
                  examples: {
                    type: "ARRAY",
                    items: { type: "STRING" },
                  },
                },
                required: [
                  "name",
                  "description",
                  "keywordDescription",
                  "flavorDescription",
                  "examples",
                ],
              },
            },
          };

          const result = await robustFetch(
            `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent`,
            mechanicPayload
          );

          const setMechanic = JSON.parse(
            result.candidates[0].content.parts[0].text
          );
          console.log("Generated set mechanic:", setMechanic);

          return setMechanic;
        } catch (error) {
          console.error("Error generating set mechanic:", error);
          return {
            name: "Risonanza",
            description:
              "Risonanza N (Quando questa carta entra nel campo di battaglia, se controlli N o pi√π permanenti con lo stesso nome nell'arte, pesca una carta.)",
            keywordDescription:
              "Risonanza (Interagisce con carte simili che controlli)",
            flavorDescription:
              "Una meccanica che rappresenta l'armonia e la connessione tra elementi simili nel set.",
            examples: [
              "Creatura con Risonanza 2",
              "Istantaneo con Risonanza 1",
              "Incantesimo che dona Risonanza",
            ],
          };
        }
      }

      function updateEstimatedTime(completedCount, totalCount) {
        const elapsedTime = (Date.now() - generationStartTime) / 1000; // in seconds
        if (completedCount === 0) return;
        const avgTimePerCard = elapsedTime / completedCount;
        const remainingCards = totalCount - completedCount;
        const estimatedSeconds = Math.round(avgTimePerCard * remainingCards);

        if (estimatedSeconds > 60) {
          timeEstimation.textContent = `Tempo stimato rimanente: ~${Math.ceil(
            estimatedSeconds / 60
          )} minuti.`;
        } else {
          timeEstimation.textContent = `Tempo stimato rimanente: ~${estimatedSeconds} secondi.`;
        }
      }

      async function processCardQueue(cardElements, blueprint, index, theme) {
        if (index >= cardElements.length || isGenerationStopped) {
          showLoading(
            false,
            isGenerationStopped
              ? "Generazione interrotta."
              : "Generazione completata!"
          );
          if (generatedCards.some((c) => c) && !isGenerationStopped)
            bulkDownloadContainer.classList.remove("hidden");
          return;
        }

        const el = cardElements[index];
        const cardBlueprint = blueprint[index];

        try {
          // 1. Generate Text with context
          showLoading(
            true,
            `Generando testo per carta ${index + 1}/${cardElements.length}...`
          );
          const contextSummary = generatedCards
            .slice(0, index)
            .filter((c) => c)
            .map((c) => `${c.name} (${c.type})`)
            .join(", ");
          const cardData = await generateCardText(
            theme,
            cardBlueprint,
            contextSummary
          );
          if (isGenerationStopped) return;

          // Post-processing: correggi automaticamente il colorIdentity se necessario
          console.log("Post-processing card:", {
            name: cardData.name,
            originalColorIdentity: cardData.colorIdentity,
            manaCost: cardData.manaCost,
            type: cardData.type,
          });

          if (cardData.manaCost) {
            const autoColorIdentity = determineColorIdentityFromManaCost(
              cardData.manaCost
            );

            // Lista dei valori abbreviati che devono essere corretti
            const abbreviatedColors = ["W", "U", "B", "R", "G"];

            if (
              !cardData.colorIdentity ||
              cardData.colorIdentity === "DA_DETERMINARE_DA_MANA_COST" ||
              abbreviatedColors.includes(cardData.colorIdentity)
            ) {
              cardData.colorIdentity = autoColorIdentity;
              console.log(
                "Updated colorIdentity from",
                cardData.colorIdentity,
                "to:",
                autoColorIdentity
              );
            }
          }

          // Post-processing: gestisci il nuovo formato strutturato per i planeswalker
          const isPlaneswalkerCard =
            cardData.type &&
            (cardData.type.toLowerCase().includes("planeswalker") ||
              cardData.startingLoyalty !== undefined ||
              cardData.abilities !== undefined);

          // PRIMA di tutto: forza il frame_style per i planeswalker
          if (isPlaneswalkerCard) {
            cardData.frame_style = "Planeswalker";
            console.log("Set frame_style to Planeswalker for:", cardData.name, {
              type: cardData.type,
              hasStartingLoyalty: cardData.startingLoyalty !== undefined,
              hasAbilities: cardData.abilities !== undefined,
            });
          }

          // Post-processing: applica regole rigorose per i planeswalker
          if (isPlaneswalkerCard) {
            console.log("Applying planeswalker rules for:", cardData.name, {
              originalRarity: cardData.rarity,
              abilitiesCount: cardData.abilities
                ? cardData.abilities.length
                : 0,
            });

            // REGOLA 1: I planeswalker NON possono MAI essere Common
            if (cardData.rarity && cardData.rarity.toLowerCase() === "common") {
              // Upgrade automatico con distribuzione pesata verso Rare/Mythic
              const upgradeRoll = Math.random();
              if (upgradeRoll < 0.15) {
                // 15% chance
                cardData.rarity = "Uncommon";
              } else if (upgradeRoll < 0.75) {
                // 60% chance (15-75%)
                cardData.rarity = "Rare";
              } else {
                // 25% chance (75-100%)
                cardData.rarity = "Mythic";
              }
              console.log(
                `Planeswalker ${cardData.name} upgraded from Common to ${cardData.rarity}`
              );
            }

            // REGOLA 2: Se √® Uncommon, massimo 2 abilit√† e nessuna ultimate
            if (
              cardData.rarity &&
              cardData.rarity.toLowerCase() === "uncommon"
            ) {
              if (cardData.abilities && cardData.abilities.length > 0) {
                let modifiedAbilities = [...cardData.abilities];

                // Rimuovi le ultimate (abilit√† con costo alto negativo, tipicamente -6 o maggiore)
                modifiedAbilities = modifiedAbilities.filter((ability) => {
                  const cost = ability.cost;
                  if (cost.startsWith("-")) {
                    const value = Math.abs(parseInt(cost.replace("-", "")));
                    if (value >= 6) {
                      console.log(
                        `Removed ultimate ability from Uncommon planeswalker ${cardData.name}: ${cost}`
                      );
                      return false;
                    }
                  }
                  return true;
                });

                // Limita a massimo 2 abilit√†
                if (modifiedAbilities.length > 2) {
                  modifiedAbilities = modifiedAbilities.slice(0, 2);
                  console.log(
                    `Limited Uncommon planeswalker ${cardData.name} to 2 abilities`
                  );
                }

                cardData.abilities = modifiedAbilities;

                // Riconverti in formato text per compatibilit√†
                if (cardData.abilities.length > 0) {
                  cardData.text = cardData.abilities
                    .map((ability) => `${ability.cost}: ${ability.description}`)
                    .join("\n");
                }
              }
            }

            // REGOLA 3: Bias verso Rare/Mythic per altri planeswalker non-Common
            if (
              cardData.rarity &&
              !["common", "uncommon"].includes(cardData.rarity.toLowerCase())
            ) {
              // Se non √® gi√† stato processato come Common o Uncommon, applica bias verso Rare/Mythic
              if (cardData.rarity.toLowerCase() === "rare") {
                // 30% chance di upgrade da Rare a Mythic
                if (Math.random() < 0.3) {
                  cardData.rarity = "Mythic";
                  console.log(
                    `Planeswalker ${cardData.name} upgraded from Rare to Mythic (bias)`
                  );
                }
              }
            }

            console.log("Final planeswalker rules applied:", {
              name: cardData.name,
              finalRarity: cardData.rarity,
              finalAbilitiesCount: cardData.abilities
                ? cardData.abilities.length
                : 0,
            });
          }

          if (isPlaneswalkerCard) {
            // Gestisci il nuovo formato strutturato delle abilit√†
            if (cardData.abilities && Array.isArray(cardData.abilities)) {
              console.log(
                "Converting structured abilities to text format for:",
                cardData.name
              );

              // Converte le abilit√† strutturate in formato text per compatibilit√†
              const formattedAbilities = cardData.abilities
                .map((ability) => `${ability.cost}: ${ability.description}`)
                .join("\n");

              cardData.text = formattedAbilities;
              console.log(
                "Structured abilities converted:",
                cardData.abilities
              );
              console.log("Final text format:", cardData.text);

              // Mantieni il campo abilities per debugging ma usa text per il rendering
            } else if (cardData.text) {
              // Gestione del formato text legacy (compatibilit√† con carte esistenti)
              const originalText = cardData.text;

              // Controlla se il testo ha il formato sbagliato (abilit√† attaccate senza newline)
              if (
                (!originalText.includes("\n") && originalText.includes(".-")) ||
                originalText.includes(".+")
              ) {
                console.log(
                  "Fixing legacy planeswalker abilities format for:",
                  cardData.name
                );

                // Correggi il formato separando le abilit√†
                let fixedText = originalText
                  // Separa prima dei segni meno preceduti da punto
                  .replace(/\.(-\d+:)/g, ".\n$1")
                  // Separa prima dei segni pi√π preceduti da punto
                  .replace(/\.(\+\d+:)/g, ".\n$1")
                  // Separa prima degli zero preceduti da punto
                  .replace(/\.(0:)/g, ".\n$1")
                  // Pulisci eventuali doppi newline
                  .replace(/\n\n/g, "\n")
                  .trim();

                if (fixedText !== originalText) {
                  cardData.text = fixedText;
                  console.log(
                    "Fixed legacy planeswalker text from:",
                    originalText
                  );
                  console.log("To:", fixedText);
                }
              }
            } else {
              console.warn(
                "Planeswalker missing both abilities and text fields:",
                cardData.name
              );
            }
          }

          generatedCards[index] = cardData;

          // 2. Generate Art
          showLoading(
            true,
            `Generando arte per "${cardData.name}" (${index + 1}/${
              cardElements.length
            })...`
          );
          updateEstimatedTime(index + 1, cardElements.length);
          const artPrompt = `Magic: The Gathering card art, epic, high fantasy digital painting. Subject: ${cardData.artDescription}`;
          const imagePayload = {
            instances: [{ prompt: artPrompt }],
            parameters: { sampleCount: 1 },
          };
          const imageResult = await robustFetch(
            `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict`,
            imagePayload
          );
          if (isGenerationStopped) return;

          if (imageResult.predictions?.[0]?.bytesBase64Encoded) {
            cardData.artImage = await loadImage(
              `data:image/png;base64,${imageResult.predictions[0].bytesBase64Encoded}`
            );
          }

          // 3. Render
          await renderCardOnCanvas(cardData, el.canvas);
          el.loadingAnimation.remove();
        } catch (error) {
          console.error(`Errore generazione carta ${index + 1}:`, error);
          if (!isGenerationStopped) {
            el.wrapper.innerHTML += `<p class="text-red-400 text-xs text-center">Errore Generazione</p>`;
            el.loadingAnimation.remove();
          }
        }

        generationTimeoutId = setTimeout(
          () => processCardQueue(cardElements, blueprint, index + 1, theme),
          200
        );
      }

      generateBtn.addEventListener("click", async () => {
        isGenerationStopped = false;
        const theme = document.getElementById("set-theme").value;
        const count = parseInt(document.getElementById("card-count").value, 10);

        if (!theme) {
          showError("Per favore, inserisci un tema per il set.");
          return;
        }

        const selectedColors = getSelectedColors();
        const mode = document.getElementById("generation-mode").value;

        // Per i set (non carte singole), genera prima la meccanica del set
        let setMechanic = null;
        if (mode !== "single" && count > 1) {
          showLoading(true, "Generando meccanica del set...");
          try {
            setMechanic = await generateSetMechanic(theme, selectedColors);
            console.log("Set mechanic generated:", setMechanic);
            displaySetMechanic(setMechanic);
          } catch (error) {
            console.error("Failed to generate set mechanic:", error);
            // Continua senza meccanica se fallisce
          }
        } else {
          // Nascondi la meccanica per carte singole
          hideSetMechanic();
        }

        const setBlueprint = createSetBlueprint(
          count,
          selectedColors,
          mode,
          setMechanic
        );

        showLoading(
          true,
          `Preparazione per la generazione di ${count} carte...`
        );
        loadingIndicatorOriginalTop = loadingIndicator.offsetTop;
        cardDisplayArea.innerHTML = "";
        errorMessage.classList.add("hidden");
        bulkDownloadContainer.classList.add("hidden");
        generatedCards = new Array(count).fill(null);
        generationStartTime = Date.now();

        const cardSkeletons = Array.from({ length: count }, (_, i) => {
          const wrapper = document.createElement("div");
          wrapper.className = "card-wrapper";
          wrapper.dataset.cardIndex = i;

          const canvas = document.createElement("canvas");
          canvas.width = CARD_WIDTH;
          canvas.height = CARD_HEIGHT;

          // Aggiungi click handler per aprire il modale
          canvas.style.cursor = "pointer";
          canvas.addEventListener("click", () => {
            if (generatedCards[i]) {
              openCardModal(generatedCards[i]);
            }
          });

          const loadingAnimation = wrapper.appendChild(
            document.createElement("div")
          );
          loadingAnimation.className = "card-loader";
          loadingAnimation.innerHTML =
            '<svg class="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path></svg>';

          const buttonGroup = document.createElement("div");
          buttonGroup.className = "flex flex-wrap justify-center gap-2 mt-2";

          const downloadButton = document.createElement("button");
          downloadButton.innerHTML = "Scarica";
          downloadButton.className =
            "bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded-lg text-xs";
          downloadButton.onclick = () =>
            downloadCard(
              canvas,
              generatedCards[i]?.name || `carta-${i + 1}`,
              generatedCards[i]?.rarity
            );

          const editButton = document.createElement("button");
          editButton.innerHTML = "Modifica";
          editButton.className =
            "bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-lg text-xs";
          editButton.onclick = () => {
            const cardIndex = parseInt(wrapper.dataset.cardIndex);
            const currentCardData = generatedCards[cardIndex];
            if (!currentCardData) return;
            const form = createInlineEditForm(
              currentCardData,
              wrapper,
              cardIndex
            );
            canvas.style.display = "none";
            wrapper.insertBefore(form, buttonGroup);
          };

          const regenArtButton = document.createElement("button");
          regenArtButton.innerHTML = "Rigenera Arte";
          regenArtButton.className =
            "bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-1 px-3 rounded-lg text-xs";
          regenArtButton.onclick = () =>
            regenerateArt(wrapper, parseInt(wrapper.dataset.cardIndex));

          buttonGroup.append(downloadButton, editButton, regenArtButton);
          wrapper.append(canvas, buttonGroup);
          cardDisplayArea.appendChild(wrapper);
          return { wrapper, canvas, loadingAnimation };
        });

        processCardQueue(cardSkeletons, setBlueprint, 0, theme);
      });

      stopBtn.addEventListener("click", () => {
        isGenerationStopped = true;
        if (generationTimeoutId) {
          clearTimeout(generationTimeoutId);
          generationTimeoutId = null;
        }
        showLoading(false, "Generazione interrotta dall'utente.");

        const allWrappers = cardDisplayArea.querySelectorAll(".card-wrapper");
        allWrappers.forEach((wrapper) => {
          const cardIndex = parseInt(wrapper.dataset.cardIndex, 10);
          if (!generatedCards[cardIndex]) {
            wrapper.remove();
          }
        });
        if (generatedCards.some((c) => c))
          bulkDownloadContainer.classList.remove("hidden");
      });

      bulkDownloadBtn.addEventListener("click", () => {
        const zip = new JSZip();
        generatedCards.forEach((cardData, i) => {
          if (!cardData) return;
          const wrapper = cardDisplayArea.querySelector(
            `[data-card-index='${i}']`
          );
          if (wrapper) {
            const canvas = wrapper.querySelector("canvas");
            const dataURL = canvas.toDataURL("image/png");
            const cleanName = cardData.name.replace(/[ /\\?%*:|"<>]/g, "_");
            const fileName = cardData.rarity
              ? `[${cardData.rarity.toUpperCase()}]_${cleanName}.png`
              : `${cleanName}.png`;
            zip.file(fileName, dataURL.split(",")[1], { base64: true });
          }
        });
        zip.generateAsync({ type: "blob" }).then((content) => {
          const link = document.createElement("a");
          link.href = URL.createObjectURL(content);
          link.download = "carte_generate.zip";
          link.click();
        });
      });

      // Event listener per aprire i booster pack
      openBoosterBtn.addEventListener("click", () => {
        openBoosterInterface();
      });

      function setupColorSelector() {
        const colorSelector = document.getElementById("color-selector");

        // Pulisci eventuali elementi esistenti per evitare duplicati
        colorSelector.innerHTML = "";

        const colors = [
          { name: "White", symbol: "{W}", color: "#fffbd5" },
          { name: "Blue", symbol: "{U}", color: "#0e68ab" },
          { name: "Black", symbol: "{B}", color: "#150b00" },
          { name: "Red", symbol: "{R}", color: "#d3202a" },
          { name: "Green", symbol: "{G}", color: "#00733e" },
          { name: "Colorless", symbol: "{C}", color: "#ccc2c0" },
        ];

        colors.forEach((colorData) => {
          const colorOption = document.createElement("div");
          colorOption.className =
            "w-12 h-12 rounded-full border-4 border-gray-600 cursor-pointer transition-all duration-200 hover:scale-110 flex items-center justify-center";
          colorOption.style.backgroundColor = colorData.color;
          colorOption.dataset.color = colorData.name;
          colorOption.title = colorData.name;

          const symbol = document.createElement("span");
          symbol.textContent = colorData.symbol.replace(/[{}]/g, "");
          symbol.className = "font-bold text-white text-sm";
          if (colorData.name === "White" || colorData.name === "Colorless") {
            symbol.className = "font-bold text-black text-sm";
          }
          colorOption.appendChild(symbol);

          colorOption.addEventListener("click", () => {
            colorOption.classList.toggle("ring-4");
            colorOption.classList.toggle("ring-yellow-400");
            colorOption.classList.toggle("ring-offset-2");
            colorOption.classList.toggle("ring-offset-gray-900");
          });

          colorSelector.appendChild(colorOption);
        });
      }

      function getSelectedColors() {
        const selectedElements = document.querySelectorAll(
          "#color-selector .ring-4"
        );
        return Array.from(selectedElements).map((el) => el.dataset.color);
      }

      document.addEventListener("DOMContentLoaded", () => {
        setupColorSelector();
        preloadAssets();
      });

      window.addEventListener("scroll", () => {
        if (
          window.innerWidth < 768 ||
          loadingIndicator.classList.contains("hidden")
        ) {
          loadingIndicator.classList.remove("desktop-sticky");
          return;
        }
        if (window.scrollY > loadingIndicatorOriginalTop) {
          loadingIndicator.classList.add("desktop-sticky");
        } else {
          loadingIndicator.classList.remove("desktop-sticky");
        }
      });

      // Funzione per determinare automaticamente il colorIdentity dal manaCost
      function determineColorIdentityFromManaCost(manaCost) {
        if (!manaCost) return "Artifact";

        const colors = [];
        if (manaCost.includes("{W}")) colors.push("White");
        if (manaCost.includes("{U}")) colors.push("Blue");
        if (manaCost.includes("{B}")) colors.push("Black");
        if (manaCost.includes("{R}")) colors.push("Red");
        if (manaCost.includes("{G}")) colors.push("Green");

        if (colors.length === 0) return "Artifact";
        if (colors.length === 1) return colors[0];
        return "Gold"; // Multicolore
      }

      // Event listener per il booster (aggiungo quello mancante)
      document.addEventListener("DOMContentLoaded", function () {
        if (openBoosterBtn) {
          openBoosterBtn.addEventListener("click", () => {
            console.log("Clicked booster button, opening interface...");
            openBoosterInterface();
          });
        }

        // Setup del selettore colori solo una volta
        setupColorSelector();
      });
    </script>
  </body>
</html>
