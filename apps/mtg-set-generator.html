<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generatore Set Magic (Generazione Stabile)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        @font-face {
            font-family: 'Beleren Smallcaps';
            src: url('https://github.com/Hakkura/Magic-Fonts/raw/main/fonts/belerensmallcaps-bold.ttf') format('truetype');
            font-weight: bold;
            font-display: swap;
        }
        @font-face {
            font-family: 'MPlantin';
            src: url('https://github.com/Hakkura/Magic-Fonts/raw/main/fonts/mplantin.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'MPlantin';
            src: url('https://github.com/Hakkura/Magic-Fonts/raw/main/fonts/mplantin-italic.ttf') format('truetype');
            font-weight: normal;
            font-style: italic;
            font-display: swap;
        }

        body {
            font-family: 'MPlantin', 'Inter', sans-serif;
            background-color: #111827;
        }
        .beleren-font {
            font-family: 'Beleren Smallcaps', sans-serif;
        }
        .card-wrapper {
            width: 100%;
            max-width: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            position: relative;
        }
        .card-wrapper canvas {
            width: 100%;
            height: auto;
            border-radius: 4.75%;
            box-shadow: 0 15px 35px rgba(0,0,0,0.5);
            transition: transform 0.3s ease;
        }
        .card-wrapper canvas:hover {
            transform: scale(1.05) rotateZ(1deg);
        }
        #initial-loading-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(17, 24, 39, 0.95);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
        }
        .card-loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(31, 41, 55, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4.75%;
        }
        #loading-indicator {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 50;
            background-color: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(4px);
            padding: 0.75rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        @media (min-width: 768px) {
            #loading-indicator {
                position: static;
                background-color: transparent;
                backdrop-filter: none;
                padding: 0;
                box-shadow: none;
            }
            #loading-indicator.desktop-sticky {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background-color: rgba(17, 24, 39, 0.9);
                backdrop-filter: blur(4px);
                padding: 0.75rem;
                box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            }
        }
        .edit-form {
            width: 100%;
            background-color: #1f2937;
            border-radius: 14px; /* Corrisponde a 4.75% di 300px */
            padding: 1rem;
            border: 2px solid #4b5563;
        }
        .edit-form input, .edit-form textarea {
            background-color: #374151;
            color: #f3f4f6;
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid #4b5563;
        }
        .edit-form label {
            font-size: 0.875rem;
            color: #9ca3af;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="initial-loading-overlay">
        <div class="text-center">
             <svg class="animate-spin h-10 w-10 text-white mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
             <p id="loading-text" class="mt-4 text-xl text-gray-300 beleren-font">Caricamento Asset e Font...</p>
        </div>
    </div>

    <div class="container mx-auto px-4 py-8">
        <header class="text-center mb-12">
            <h1 class="beleren-font text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-yellow-300 via-orange-400 to-red-500">
                Generatore di Set MTG
            </h1>
            <p class="text-gray-400 mt-2">Crea carte di Magic ad alta fedelt√†, pronte per essere scaricate e stampate.</p>
        </header>

        <div class="max-w-2xl mx-auto bg-gray-800/50 backdrop-blur-sm rounded-xl shadow-2xl p-8 mb-12">
            <div class="space-y-6">
                <div>
                    <label for="set-theme" class="block text-lg font-medium text-gray-300 mb-2">Tema del Set</label>
                    <input type="text" id="set-theme" class="w-full bg-gray-700 text-white rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500" placeholder="Es. Impero Romano intergalattico...">
                </div>
                <div>
                    <label for="card-count" class="block text-lg font-medium text-gray-300 mb-2">Numero di Carte da Generare</label>
                    <input type="number" id="card-count" class="w-full bg-gray-700 text-white rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500" value="20" min="1" max="300">
                </div>
            </div>
            <div class="mt-8 text-center">
                <button id="generate-btn" disabled class="beleren-font bg-gray-500 cursor-not-allowed text-white font-bold py-3 px-10 rounded-lg shadow-lg transition-all duration-300">
                    Caricamento...
                </button>
                <button id="stop-btn" class="hidden beleren-font bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-10 rounded-lg shadow-lg transition-all duration-300">
                    Interrompi Generazione
                </button>
            </div>
        </div>

        <div id="bulk-download-container" class="hidden text-center my-6">
             <button id="bulk-download-btn" class="beleren-font bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-lg">
                Scarica Tutte le Carte (.zip)
            </button>
        </div>

        <div id="loading-indicator" class="hidden text-center my-10">
            <div class="flex items-center justify-center">
                 <svg class="animate-spin h-8 w-8 text-white mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                <div>
                    <p id="generation-status" class="text-gray-300">L'AI sta forgiando le carte...</p>
                    <p id="time-estimation" class="text-gray-400 text-sm"></p>
                </div>
            </div>
        </div>
        
        <div id="error-message" class="hidden text-center my-10 bg-red-500/20 text-red-300 p-4 rounded-lg"></div>

        <div id="card-display-area" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-8 justify-items-center">
        </div>
    </div>

<script>
    // Elements
    const generateBtn = document.getElementById('generate-btn');
    const stopBtn = document.getElementById('stop-btn');
    const bulkDownloadContainer = document.getElementById('bulk-download-container');
    const bulkDownloadBtn = document.getElementById('bulk-download-btn');
    const loadingIndicator = document.getElementById('loading-indicator');
    const generationStatus = document.getElementById('generation-status');
    const timeEstimation = document.getElementById('time-estimation');
    const cardDisplayArea = document.getElementById('card-display-area');
    const errorMessage = document.getElementById('error-message');
    const initialLoadingOverlay = document.getElementById('initial-loading-overlay');
    
    // State
    let isGenerationStopped = false;
    let generatedCards = []; 
    let generationTimeoutId = null;
    let generationStartTime = 0;
    let loadingIndicatorOriginalTop = 0;

    // Constants
    const CARD_WIDTH = 375;
    const CARD_HEIGHT = 523;
    const assets = { frames: {}, ptBox: {}, symbols: {} };
    const MTG_CARDSMITH_BASE = 'https://mtgcardsmith.com';
    const FRAME_ASSETS = {
        'Standard Colors': { 'White': '/moderator/thumb/custom_666b5f5b0a7b2.jpg?v=1', 'Blue': '/moderator/thumb/custom_666b66c13041d.jpg?v=1', 'Black': '/moderator/thumb/custom_666b62e1659a8.jpg?v=1', 'Red': '/moderator/thumb/custom_666b637f49d3c.jpg?v=1', 'Green': '/moderator/thumb/custom_666b647f32017.jpg?v=1', 'Artifact': '/moderator/thumb/custom_666b64b05d996.jpg?v=1', 'Colorless': '/moderator/thumb/custom_666b64d958319.jpg?v=1', 'Land': '/moderator/thumb/custom_666b64d958319.jpg?v=1', 'Gold': '/moderator/thumb/custom_666ba621b8c9d.png?v=1' },
        'Borderless': { 'White': '/moderator/thumb/custom_66637c40bf2a2.png?v=1', 'White Legend': '/moderator/thumb/custom_666389e5e46a1.png?v=1', 'Blue': '/moderator/thumb/custom_6663822aa3c55.png?v=1', 'Blue Legend': '/moderator/thumb/custom_666382be85178.png?v=1', 'Black': '/moderator/thumb/custom_6663830c90efd.png?v=1', 'Black Legend': '/moderator/thumb/custom_666383273f96e.png?v=1', 'Red': '/moderator/thumb/custom_6663833f965ba.png?v=1', 'Red Legend': '/moderator/thumb/custom_66638376b7b51.png?v=1', 'Green': '/moderator/thumb/custom_666388ec7e198.png?v=1', 'Green Legend': '/moderator/thumb/custom_666389293baab.png?v=1', 'Gold': '/moderator/thumb/custom_66638b4a98a6e.png?v=1', 'Gold Legend': '/moderator/thumb/custom_66638b876689f.png?v=1', 'Artifact': '/moderator/thumb/custom_66638ba07c65e.png?v=1', 'Artifact Legend': '/moderator/thumb/custom_66638bcd6c326.png?v=1', 'Land': '/moderator/thumb/custom_66638ca862a35.png?v=1', 'Land Legend': '/moderator/thumb/custom_66638ce7c7962.png?v=1', 'Colorless': '/moderator/thumb/custom_66638d05e06de.png?v=1', 'Colorless Legend': '/moderator/thumb/custom_66638d29593a9.png?v=1' }
    };
    const PT_BOX_ASSETS = {
        'Standard': { 'Black': '/moderator/ptImgs/custom_66638540b2307.png', 'White': '/moderator/ptImgs/custom_666383e4ba24e.png', 'Blue': '/moderator/ptImgs/custom_66638454b50c0.png', 'Red': '/moderator/ptImgs/custom_6663850c4c508.png', 'Green': '/moderator/ptImgs/custom_6663851f571d5.png', 'Artifact': '/moderator/ptImgs/custom_66638535808c3.png', 'Colorless': '/moderator/ptImgs/custom_66638540b2307.png', 'Gold': '/moderator/ptImgs/custom_66576b60da360.png' },
        'Borderless': { 'Black': '/moderator/ptImgs/custom_6663824ab6918.png', 'White': '/moderator/ptImgs/custom_6663811764b39.png', 'Blue': '/moderator/ptImgs/custom_66638241c552b.png', 'Red': '/moderator/ptImgs/custom_6663824f56d90.png', 'Green': '/moderator/ptImgs/custom_6663825ebab9f.png', 'Artifact': '/moderator/ptImgs/custom_66638267b0ce4.png', 'Colorless': '/moderator/ptImgs/custom_6663827878b84.png', 'Gold': '/moderator/ptImgs/custom_666382623fb86.png' }
    };
    const ITALIAN_KEYWORDS = ['Attacco improvviso','Cautela','Difensore','Doppio attacco','Incanta','Equipaggia','Lampo','Volare','Rapidit√†','Intimidire','Indistruttibile','Legame vitale','Protezione','Raggiungere','Travolgere','Passa-isole','Passa-foreste','Passa-montagne','Passa-paludi','Anti-malocchio','Furtivit√†','Ombra','Rigenerare','Attacco letale','Velo'];
    const apiKey = ""; // Gestita dall'ambiente

    // --- Asset & Core Functions ---

    function loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => resolve(img);
            img.onerror = (e) => reject(`Impossibile caricare l'asset da ${src}. Errore: ${e}`);
            img.src = src;
        });
    }

    async function preloadAssets() {
        const assetPromises = [];
        for (const style in FRAME_ASSETS) {
            if (!assets.frames[style]) assets.frames[style] = {};
            for (const color in FRAME_ASSETS[style]) {
                const url = MTG_CARDSMITH_BASE + FRAME_ASSETS[style][color];
                assetPromises.push(loadImage(url).then(img => { assets.frames[style][color] = img; }).catch(e => console.warn(e)));
            }
        }
        for (const style in PT_BOX_ASSETS) {
             if (!assets.ptBox[style]) assets.ptBox[style] = {};
            for (const color in PT_BOX_ASSETS[style]) {
                const url = MTG_CARDSMITH_BASE + PT_BOX_ASSETS[style][color];
                assetPromises.push(loadImage(url).then(img => { assets.ptBox[style][color] = img; }).catch(e => console.warn(e)));
            }
        }

        try {
            await Promise.all([ ...assetPromises, document.fonts.ready, preloadScryfallSymbols() ]);
            initialLoadingOverlay.style.display = 'none';
            generateBtn.disabled = false;
            generateBtn.textContent = 'Genera Carte';
            generateBtn.className = 'beleren-font bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white font-bold py-3 px-10 rounded-lg shadow-lg transform hover:scale-105 transition-transform duration-300';
        } catch (error) {
            console.error(error);
            initialLoadingOverlay.innerHTML = `<div class="text-center text-red-400 p-8"><p class="beleren-font text-2xl">Errore Critico</p><p class="mt-2">${error}</p><p class="text-sm mt-2">Nota: Il caricamento diretto da mtgcardsmith.com potrebbe essere bloccato dal browser per motivi di sicurezza (CORS). Ricarica la pagina per riprovare.</p></div>`;
        }
    }
    
    async function preloadScryfallSymbols() {
        try {
            const response = await fetch('https://api.scryfall.com/symbology');
            if (!response.ok) throw new Error(`API Scryfall per simbologia ha risposto con ${response.status}`);
            const result = await response.json();
            const symbolPromises = result.data.map(symbolData => {
                return new Promise(async (resolve) => {
                    try {
                        if (symbolData.svg_uri) {
                            await new Promise(r => setTimeout(r, 50)); // Rate limit
                            const symbolImage = await loadImage(symbolData.svg_uri, true);
                            assets.symbols[symbolData.symbol] = symbolImage;
                        }
                    } catch (e) {
                         console.warn(`Fallito il caricamento del simbolo: ${symbolData.symbol}`);
                    }
                    resolve();
                });
            });
            await Promise.all(symbolPromises);
        } catch (error) {
            console.error("Errore fatale nel caricare i simboli da Scryfall:", error);
            throw error;
        }
    }

    // --- Canvas Rendering ---
    
    function drawFittingText(ctx, text, initialFont, maxWidth) {
        let fontSize = parseInt(initialFont.split('px')[0]);
        let fontName = initialFont.split('px')[1];
        ctx.font = initialFont;
        while (ctx.measureText(text).width > maxWidth && fontSize > 8) {
            fontSize--;
            ctx.font = `${fontSize}px${fontName}`;
        }
        return ctx.font;
    }

    async function renderCardOnCanvas(cardData, canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, CARD_WIDTH, CARD_HEIGHT);
        
        const getFrameAsset = (data) => {
            const isLegendary = data.type.toLowerCase().includes('leggendario') || data.type.toLowerCase().includes('leggendaria');
            const style = data.frame_style || 'Standard Colors';
            let key = data.colorIdentity + (isLegendary && style === 'Borderless' ? ' Legend' : '');
            return assets.frames[style]?.[key] || assets.frames['Standard Colors'][data.colorIdentity] || assets.frames['Standard Colors'].Artifact;
        };
        const getPtBoxAsset = (data) => {
            const style = data.frame_style === 'Borderless' ? 'Borderless' : 'Standard';
            return assets.ptBox[style]?.[data.colorIdentity] || assets.ptBox[style]?.Artifact;
        };

        const frame = getFrameAsset(cardData);
        const isBorderless = cardData.frame_style === 'Borderless';
        
        if (cardData.artImage?.complete) {
            const box = { x: 28, y: 55, w: 319, h: 236 };
            if (isBorderless) { Object.assign(box, { x: 0, y: 0, w: CARD_WIDTH, h: CARD_HEIGHT }); }
            const imgRatio = cardData.artImage.width / cardData.artImage.height;
            const boxRatio = box.w / box.h;
            let finalW, finalH, finalX, finalY;
            if (imgRatio > boxRatio) {
                finalH = box.h; finalW = finalH * imgRatio; finalX = box.x - (finalW - box.w) / 2; finalY = box.y;
            } else {
                finalW = box.w; finalH = finalW / imgRatio; finalX = box.x; finalY = box.y - (finalH - box.h) / 2;
            }
            ctx.save();
            ctx.beginPath();
            ctx.rect(box.x, box.y, box.w, box.h);
            ctx.clip();
            ctx.drawImage(cardData.artImage, finalX, finalY, finalW, finalH);
            ctx.restore();
        }

        if (frame?.complete) ctx.drawImage(frame, 0, 0, CARD_WIDTH, CARD_HEIGHT);

        ctx.save();
        ctx.fillStyle = isBorderless ? 'white' : 'black';
        if (isBorderless) {
            Object.assign(ctx, { shadowColor: 'rgba(0,0,0,0.8)', shadowBlur: 4, shadowOffsetX: 2, shadowOffsetY: 2 });
        }

        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.font = drawFittingText(ctx, cardData.name, "bold 18px 'Beleren Smallcaps'", 280);
        ctx.fillText(cardData.name, 32, 40); 
        
        ctx.font = drawFittingText(ctx, cardData.type, "bold 16px 'Beleren Smallcaps'", 280);
        ctx.fillText(cardData.type, 32, 310);
        
        drawSetSymbol(ctx, cardData.rarity, 341, 310);
        
        ctx.fillStyle = isBorderless ? 'white' : 'black';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
        
        await drawTextWithMana(ctx, cardData.text || '', 35, 346, 305, 18); 

        await drawManaCost(ctx, cardData.manaCost, 345, 40);
        
        if (cardData.power && cardData.toughness && cardData.power !== 'null' && cardData.toughness !== 'null') {
            const ptBox = getPtBoxAsset(cardData);
            if (ptBox?.complete) ctx.drawImage(ptBox, 295, 470, 60, 30);
            Object.assign(ctx, { fillStyle: isBorderless ? 'white' : 'black', font: "bold 22px 'Beleren Smallcaps'", textAlign: 'center', textBaseline: 'middle' });
            ctx.fillText(`${cardData.power}/${cardData.toughness}`, 325, 485);
        }
        ctx.restore();
    }
    
    async function drawManaCost(ctx, cost, x, y) {
        if (!cost) return;
        const symbols = cost.match(/\{[^{}]+\}/g) || [];
        let currentX = x;
        const symbolSize = 20;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let i = symbols.length - 1; i >= 0; i--) {
            const symbolImage = assets.symbols[symbols[i]];
            if (symbolImage?.complete) {
                ctx.drawImage(symbolImage, currentX - symbolSize, y - symbolSize/2, symbolSize, symbolSize);
                currentX -= (symbolSize + 2);
            }
        }
    }
    
    function drawSetSymbol(ctx, rarity, x, y) {
        const radius = 8;
        const centerX = x - radius;
        const centerY = y;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
        const rarityColors = { 'Uncommon': '#c0c0c0', 'Rare': '#ffd700', 'Mythic': '#ff4500' };
        ctx.fillStyle = rarityColors[rarity] || 'black';
        ctx.fill();
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    async function drawTextWithMana(ctx, text, x, y, maxWidth, initialLineHeight) {
        if (!text) return y;
        let fontSize = 15, lineHeight = 18;
        const calculateTextHeight = (txt, fSize, lHeight) => {
            ctx.font = `${fSize}px 'MPlantin'`;
            let tempY = 0, currentLineWidth = 0;
            const parts = txt.split(/(\{[^{}]+\}|\n|\s)/g);
            for (const part of parts) {
                if (!part) continue;
                if (part === '\n') { tempY += lHeight; currentLineWidth = 0; continue; }
                const partWidth = part.startsWith('{') ? fSize : ctx.measureText(part).width;
                if (currentLineWidth + partWidth > maxWidth && currentLineWidth > 0) {
                    tempY += lHeight; currentLineWidth = 0;
                }
                currentLineWidth += partWidth;
            }
            return tempY + lHeight;
        };
        while (fontSize > 10) {
            if (calculateTextHeight(text, fontSize, lineHeight) <= 120) break;
            fontSize -= 1;
            lineHeight = Math.floor(initialLineHeight * (fontSize / 15));
        }
        ctx.font = `${fontSize}px 'MPlantin'`;
        let currentX = x, currentY = y;
        const parts = text.split(/(\{[^{}]+\}|\n|\s)/g);
        for (const part of parts) {
            if (!part) continue;
            if (part === '\n') { currentX = x; currentY += lineHeight; continue; }
            if (part === ' ') { currentX += ctx.measureText(' ').width; continue; }
            const isSymbol = part.startsWith('{');
            const partWidth = isSymbol ? fontSize * 1.1 : ctx.measureText(part).width;
            if (currentX + partWidth > x + maxWidth && currentX > x) {
                currentX = x; currentY += lineHeight;
            }
            if (isSymbol) {
                const symbolImage = assets.symbols[part];
                if (symbolImage?.complete) {
                    ctx.drawImage(symbolImage, currentX, currentY - (fontSize*0.8), fontSize, fontSize);
                }
            } else {
                ctx.fillText(part, currentX, currentY);
            }
            currentX += partWidth;
        }
        return currentY;
    }

    // --- UI & Event Handlers ---

    function downloadCard(canvas, cardName) {
        const link = document.createElement('a');
        link.download = `${cardName.replace(/[ /\\?%*:|"<>]/g, '_')}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
    }

    const showLoading = (isLoading, message = "L'AI sta forgiando le carte...") => {
        loadingIndicator.classList.toggle('hidden', !isLoading);
        generationStatus.textContent = message;
        generateBtn.disabled = isLoading;
        stopBtn.classList.toggle('hidden', !isLoading);
        generateBtn.textContent = isLoading ? "Generazione..." : 'Genera Carte';
        generateBtn.classList.toggle('opacity-50', isLoading);
        generateBtn.classList.toggle('cursor-not-allowed', isLoading);
        if (!isLoading) {
            timeEstimation.textContent = '';
            loadingIndicator.classList.remove('desktop-sticky');
        }
    };

    const showError = (message) => {
        errorMessage.textContent = message;
        errorMessage.classList.remove('hidden');
    }
    
    function createInlineEditForm(cardData, wrapper, cardIndex) {
        const form = document.createElement('div');
        form.className = 'edit-form space-y-2';
        form.innerHTML = `
            <div><label>Nome:</label><input type="text" value="${cardData.name || ''}"></div>
            <div><label>Costo:</label><input type="text" value="${cardData.manaCost || ''}"></div>
            <div><label>Tipo:</label><input type="text" value="${cardData.type || ''}"></div>
            <div><label>Testo:</label><textarea rows="3">${cardData.text || ''}</textarea></div>
            <div class="grid grid-cols-2 gap-2">
                <div><label>Forza:</label><input type="text" value="${cardData.power || ''}"></div>
                <div><label>Cost.:</label><input type="text" value="${cardData.toughness || ''}"></div>
            </div>
            <div class="flex justify-end gap-2 pt-2">
                <button class="cancel-edit-btn bg-gray-600 hover:bg-gray-700 py-1 px-3 rounded text-sm">Annulla</button>
                <button class="save-edit-btn bg-green-600 hover:bg-green-700 py-1 px-3 rounded text-sm">Salva</button>
            </div>
        `;
        
        const canvas = wrapper.querySelector('canvas');

        form.querySelector('.save-edit-btn').addEventListener('click', () => {
            const inputs = form.querySelectorAll('input, textarea');
            const updatedCardData = generatedCards[cardIndex];
            
            updatedCardData.name = inputs[0].value;
            updatedCardData.manaCost = inputs[1].value;
            updatedCardData.type = inputs[2].value;
            updatedCardData.text = inputs[3].value;
            updatedCardData.power = inputs[4].value;
            updatedCardData.toughness = inputs[5].value;
            
            renderCardOnCanvas(updatedCardData, canvas);
            form.remove();
            canvas.style.display = 'block';
        });

        form.querySelector('.cancel-edit-btn').addEventListener('click', () => {
            form.remove();
            canvas.style.display = 'block';
        });

        return form;
    }

    async function regenerateArt(wrapper, cardIndex) {
        const cardData = generatedCards[cardIndex];
        const canvas = wrapper.querySelector('canvas');

        const loader = document.createElement('div');
        loader.className = 'card-loader';
        loader.innerHTML = '<svg class="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path></svg>';
        wrapper.prepend(loader);

        try {
            const artPrompt = `Magic: The Gathering card art, epic, high fantasy digital painting. Subject: ${cardData.artDescription}`;
            const imagePayload = { instances: [{ prompt: artPrompt }], parameters: { "sampleCount": 1 } };
            const imageResult = await robustFetch(`https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict`, imagePayload);
            if (imageResult.predictions?.[0]?.bytesBase64Encoded) {
                cardData.artImage = await loadImage(`data:image/png;base64,${imageResult.predictions[0].bytesBase64Encoded}`);
            }
            await renderCardOnCanvas(cardData, canvas);
        } catch (error) {
            console.error('Errore rigenerazione arte:', error);
            showError(`Errore rigenerazione arte per ${cardData.name}.`);
        } finally {
            loader.remove();
        }
    }
    
    // --- Main Generation Logic ---

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function createSetBlueprint(totalCount) {
        const blueprint = Array.from({ length: totalCount }, () => ({}));

        // 1. Assign Rarities
        const rarities = [];
        const mythicCount = Math.round(totalCount * 0.075);
        const rareCount = Math.round(totalCount * 0.225);
        const uncommonCount = Math.round(totalCount * 0.38);
        const commonCount = totalCount - mythicCount - rareCount - uncommonCount;
        for (let i = 0; i < mythicCount; i++) rarities.push('Mythic');
        for (let i = 0; i < rareCount; i++) rarities.push('Rare');
        for (let i = 0; i < uncommonCount; i++) rarities.push('Uncommon');
        for (let i = 0; i < commonCount; i++) rarities.push('Common');
        shuffleArray(rarities);
        blueprint.forEach((card, i) => card.rarity = rarities[i]);

        // 2. Assign Types
        const types = [];
        const creatureCount = Math.round(totalCount * 0.55);
        const spellCount = Math.round(totalCount * 0.28);
        const permanentCount = Math.round(totalCount * 0.12);
        const landCount = totalCount - creatureCount - spellCount - permanentCount;
        for (let i = 0; i < creatureCount; i++) types.push('Creatura');
        for (let i = 0; i < spellCount; i++) types.push('Istantaneo o Stregoneria');
        for (let i = 0; i < permanentCount; i++) types.push('Incantesimo o Artefatto');
        for (let i = 0; i < landCount; i++) types.push('Terra non base');
        shuffleArray(types);
        blueprint.forEach((card, i) => card.type = types[i]);

        // 3. Assign Colors
        const colors = [];
        const nonLandCards = blueprint.filter(card => card.type !== 'Terra non base');
        const nonLandCount = nonLandCards.length;
        
        const multicolorCount = Math.round(nonLandCount * 0.13);
        const colorlessCount = Math.round(nonLandCount * 0.08);
        const monocolorTotal = nonLandCount - multicolorCount - colorlessCount;
        const perColorCount = Math.floor(monocolorTotal / 5);
        
        for (let i = 0; i < multicolorCount; i++) colors.push('Gold');
        for (let i = 0; i < colorlessCount; i++) colors.push('Artifact');
        ['White', 'Blue', 'Black', 'Red', 'Green'].forEach(color => {
            for (let i = 0; i < perColorCount; i++) colors.push(color);
        });
        // Distribute remaining monocolor cards
        const remainder = monocolorTotal % 5;
        const allColors = ['White', 'Blue', 'Black', 'Red', 'Green'];
        shuffleArray(allColors);
        for(let i=0; i<remainder; i++) colors.push(allColors[i]);

        shuffleArray(colors);
        
        let colorIndex = 0;
        blueprint.forEach(card => {
            if (card.type === 'Terra non base') {
                card.colorIdentity = 'Land';
            } else if (colorIndex < colors.length) {
                card.colorIdentity = colors[colorIndex++];
            } else { // Fallback
                card.colorIdentity = 'Artifact';
            }
        });

        return blueprint;
    }

    async function robustFetch(url, payload, retries = 3) {
        for (let i = 0; i < retries; i++) {
            if (isGenerationStopped) throw new Error("Generazione interrotta dall'utente.");
            try {
                const response = await fetch(`${url}?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (response.ok) return await response.json();
                if (response.status === 429) { 
                    console.warn(`Rate limit hit. Tentativo ${i + 1}. Attendo...`);
                    await new Promise(res => setTimeout(res, 2000 * (i + 1))); 
                } else {
                    const errorBody = await response.text();
                    throw new Error(`API Error: ${response.status}. Body: ${errorBody}`);
                }
            } catch (error) {
                console.error(`Fetch fallito (tentativo ${i + 1}):`, error);
                if (i === retries - 1) throw error;
            }
        }
    }

    async function generateCardText(theme, cardBlueprint, history) {
        const historyPrompt = history.length > 0
            ? `Finora, hai creato le seguenti carte in questo set: ${history}. Basandoti su queste, crea la nuova carta.`
            : `Questa √® l'inizio di un nuovo set. Crea la prima carta.`;

        const instructionPrompt = `Crea una carta di Magic: The Gathering per un set a tema "${theme}". La carta DEVE rispettare queste specifiche: Tipo: ${cardBlueprint.type}, Rarit√†: ${cardBlueprint.rarity}, Colore: ${cardBlueprint.colorIdentity}. ${historyPrompt} TUTTO il testo della carta, inclusi i nomi delle abilit√†, DEVE essere in italiano. Utilizza le abilit√† ufficiali italiane quando possibile, come: ${ITALIAN_KEYWORDS.join(', ')}. La carta deve essere bilanciata. Il formato del costo di mana deve essere corretto (es. {2}{W}{U}). Fornisci un oggetto JSON con: name, manaCost, type (in italiano, specifico, es. 'Creatura - Guerriero Umano'), text (in italiano, con simboli mana), power (per creature), toughness (per creature), artDescription (descrizione vivida per AI). L'oggetto JSON DEVE avere i campi "colorIdentity", "rarity" e "frame_style" impostati rispettivamente a "${cardBlueprint.colorIdentity}", "${cardBlueprint.rarity}" e "Standard Colors". NON includere 'flavorText'. Rispondi solo con un oggetto JSON valido.`;
        
        const textGenPayload = {
            contents: [{ role: "user", parts: [{ text: instructionPrompt }] }],
            generationConfig: { responseMimeType: "application/json", responseSchema: { type: "OBJECT", properties: { "name": { "type": "STRING" }, "manaCost": { "type": "STRING" }, "colorIdentity": { "type": "STRING" }, "rarity": { "type": "STRING" }, "type": { "type": "STRING" }, "frame_style": { "type": "STRING" }, "text": { "type": "STRING" }, "power": { "type": "STRING" }, "toughness": { "type": "STRING" }, "artDescription": { "type": "STRING" } }, required: ["name", "manaCost", "colorIdentity", "rarity", "type", "frame_style", "text", "artDescription"] } }
        };
        const textResult = await robustFetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent`, textGenPayload);
        return JSON.parse(textResult.candidates[0].content.parts[0].text);
    }

    function updateEstimatedTime(completedCount, totalCount) {
        const elapsedTime = (Date.now() - generationStartTime) / 1000; // in seconds
        if (completedCount === 0) return;
        const avgTimePerCard = elapsedTime / completedCount;
        const remainingCards = totalCount - completedCount;
        const estimatedSeconds = Math.round(avgTimePerCard * remainingCards);

        if (estimatedSeconds > 60) {
            timeEstimation.textContent = `Tempo stimato rimanente: ~${Math.ceil(estimatedSeconds / 60)} minuti.`;
        } else {
            timeEstimation.textContent = `Tempo stimato rimanente: ~${estimatedSeconds} secondi.`;
        }
    }

    async function processCardQueue(cardElements, blueprint, index, theme) {
        if (index >= cardElements.length || isGenerationStopped) {
            showLoading(false, isGenerationStopped ? "Generazione interrotta." : "Generazione completata!");
            if (generatedCards.some(c => c) && !isGenerationStopped) bulkDownloadContainer.classList.remove('hidden');
            return;
        }

        const el = cardElements[index];
        const cardBlueprint = blueprint[index];
        
        try {
            // 1. Generate Text with context
            showLoading(true, `Generando testo per carta ${index + 1}/${cardElements.length}...`);
            const contextSummary = generatedCards.slice(0, index).filter(c => c).map(c => `${c.name} (${c.type})`).join(', ');
            const cardData = await generateCardText(theme, cardBlueprint, contextSummary);
            if (isGenerationStopped) return;
            generatedCards[index] = cardData; 
            
            // 2. Generate Art
            showLoading(true, `Generando arte per "${cardData.name}" (${index + 1}/${cardElements.length})...`);
            updateEstimatedTime(index + 1, cardElements.length);
            const artPrompt = `Magic: The Gathering card art, epic, high fantasy digital painting. Subject: ${cardData.artDescription}`;
            const imagePayload = { instances: [{ prompt: artPrompt }], parameters: { "sampleCount": 1 } };
            const imageResult = await robustFetch(`https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict`, imagePayload);
            if (isGenerationStopped) return;

            if (imageResult.predictions?.[0]?.bytesBase64Encoded) {
                cardData.artImage = await loadImage(`data:image/png;base64,${imageResult.predictions[0].bytesBase64Encoded}`);
            }

            // 3. Render
            await renderCardOnCanvas(cardData, el.canvas);
            el.loadingAnimation.remove();

        } catch (error) {
            console.error(`Errore generazione carta ${index + 1}:`, error);
            if (!isGenerationStopped) {
                el.wrapper.innerHTML += `<p class="text-red-400 text-xs text-center">Errore Generazione</p>`;
                el.loadingAnimation.remove();
            }
        }
        
        generationTimeoutId = setTimeout(() => processCardQueue(cardElements, blueprint, index + 1, theme), 200);
    }

    generateBtn.addEventListener('click', async () => {
        isGenerationStopped = false;
        const theme = document.getElementById('set-theme').value;
        const count = parseInt(document.getElementById('card-count').value, 10);
        if (!theme) { showError('Per favore, inserisci un tema per il set.'); return; }
        
        const setBlueprint = createSetBlueprint(count);
        
        showLoading(true, `Preparazione per la generazione di ${count} carte...`);
        loadingIndicatorOriginalTop = loadingIndicator.offsetTop;
        cardDisplayArea.innerHTML = '';
        errorMessage.classList.add('hidden');
        bulkDownloadContainer.classList.add('hidden');
        generatedCards = new Array(count).fill(null); 
        generationStartTime = Date.now();

        const cardSkeletons = Array.from({ length: count }, (_, i) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'card-wrapper';
            wrapper.dataset.cardIndex = i;

            const canvas = document.createElement('canvas');
            canvas.width = CARD_WIDTH;
            canvas.height = CARD_HEIGHT;
            
            const loadingAnimation = wrapper.appendChild(document.createElement('div'));
            loadingAnimation.className = 'card-loader';
            loadingAnimation.innerHTML = '<svg class="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path></svg>';
            
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'flex flex-wrap justify-center gap-2 mt-2';
            
            const downloadButton = document.createElement('button');
            downloadButton.innerHTML = 'Scarica';
            downloadButton.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded-lg text-xs';
            downloadButton.onclick = () => downloadCard(canvas, generatedCards[i]?.name || `carta-${i+1}`);

            const editButton = document.createElement('button');
            editButton.innerHTML = 'Modifica';
            editButton.className = 'bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-lg text-xs';
            editButton.onclick = () => {
                const cardIndex = parseInt(wrapper.dataset.cardIndex);
                const currentCardData = generatedCards[cardIndex];
                if (!currentCardData) return;
                const form = createInlineEditForm(currentCardData, wrapper, cardIndex);
                canvas.style.display = 'none';
                wrapper.insertBefore(form, buttonGroup);
            };

            const regenArtButton = document.createElement('button');
            regenArtButton.innerHTML = 'Rigenera Arte';
            regenArtButton.className = 'bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-1 px-3 rounded-lg text-xs';
            regenArtButton.onclick = () => regenerateArt(wrapper, parseInt(wrapper.dataset.cardIndex));

            buttonGroup.append(downloadButton, editButton, regenArtButton);
            wrapper.append(canvas, buttonGroup);
            cardDisplayArea.appendChild(wrapper);
            return { wrapper, canvas, loadingAnimation };
        });

        processCardQueue(cardSkeletons, setBlueprint, 0, theme);
    });
    
    stopBtn.addEventListener('click', () => {
        isGenerationStopped = true;
        if(generationTimeoutId) {
            clearTimeout(generationTimeoutId);
            generationTimeoutId = null;
        }
        showLoading(false, "Generazione interrotta dall'utente.");
        
        const allWrappers = cardDisplayArea.querySelectorAll('.card-wrapper');
        allWrappers.forEach(wrapper => {
            const cardIndex = parseInt(wrapper.dataset.cardIndex, 10);
            if (!generatedCards[cardIndex]) {
                wrapper.remove();
            }
        });
        if (generatedCards.some(c => c)) bulkDownloadContainer.classList.remove('hidden');
    });

    bulkDownloadBtn.addEventListener('click', () => {
        const zip = new JSZip();
        generatedCards.forEach((cardData, i) => {
            if (!cardData) return;
            const wrapper = cardDisplayArea.querySelector(`[data-card-index='${i}']`);
            if (wrapper) {
                const canvas = wrapper.querySelector('canvas');
                const dataURL = canvas.toDataURL('image/png');
                zip.file(`${cardData.name.replace(/[ /\\?%*:|"<>]/g, '_')}.png`, dataURL.split(',')[1], {base64: true});
            }
        });
        zip.generateAsync({type:"blob"}).then(content => {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(content);
            link.download = "carte_generate.zip";
            link.click();
        });
    });
    
    document.addEventListener('DOMContentLoaded', preloadAssets);

    window.addEventListener('scroll', () => {
        if (window.innerWidth < 768 || loadingIndicator.classList.contains('hidden')) {
            loadingIndicator.classList.remove('desktop-sticky');
            return;
        }
        if (window.scrollY > loadingIndicatorOriginalTop) {
            loadingIndicator.classList.add('desktop-sticky');
        } else {
            loadingIndicator.classList.remove('desktop-sticky');
        }
    });

</script>
</body>
</html>
